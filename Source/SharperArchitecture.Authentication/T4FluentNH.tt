<#@ template language="C#" debug="true" hostSpecific="true"#>
<#@ assembly name="System.Core" #>
<#@ assembly name="System.Configuration" #>
<#@ assembly name="EnvDTE"#>
<#@ assembly name="EnvDTE80" #>
<#@ assembly Name="System.Data.dll" #>
<#@ assembly Name="System.Data.Entity.dll" #>
<#@ assembly Name="System.Data.Entity.Design.dll" #>
<#@ assembly name="System.Xml" #>
<#@ assembly name="System.Xml.Linq" #>
<#@ assembly name="Microsoft.VisualStudio.Shell.Interop.8.0" #>
<#@ assembly Name="System.Windows.Forms.dll" #>
<#@ assembly name="VSLangProj" #>
<#@ import namespace="System" #>
<#@ import namespace="System.Reflection" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Configuration" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Security.Policy" #>
<#@ import namespace="System.Xml.Linq" #>
<#@ import namespace="System.Xml.Schema" #>
<#@ import namespace="System.Xml.XPath" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Globalization" #>
<#@ import namespace="System.Data" #>
<#@ import namespace="System.Data.SqlClient" #>
<#@ import namespace="System.Data.Entity" #>
<#@ import namespace="System.Data.Entity.Design.PluralizationServices" #>
<#@ import namespace="System.Diagnostics" #>
<#@ import namespace="System.Windows.Forms" #>
<#@ import namespace="System.Collections" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Text.RegularExpressions" #>
<#@ import namespace="EnvDTE" #>
<#@ import namespace="EnvDTE80" #>
<#@ import namespace="Microsoft.CSharp" #>
<#@ import namespace="Microsoft.VisualStudio.Shell.Interop" #>
<#@ import namespace="Microsoft.VisualStudio.TextTemplating" #>
// <auto-generated />
// This file was generated by a T4 template.
// Don't change it directly as your change would get overwritten.  Instead, make changes
// to the .tt file (i.e. the T4 template) and save it to regenerate this file.

// Make sure the compiler doesn't complain about missing Xml comments

<# 
	// create an instance of the AutomationHelper class so 
	// that it is accessible from everywhere within the template
	//this.VisualStudioHelper = new AutomationHelper(this.Host);
	VSHelper = new VisualStudioHelper(this);
#>




<#
//System.Diagnostics.Debugger.Launch();
//System.Diagnostics.Debugger.Break();    +


var debug = false;


var globalWatch = Stopwatch.StartNew();
var stepWatch = debug ? Stopwatch.StartNew() : null;

GlobalContainer.VSHelper = VSHelper;
GlobalContainer.ProjectItems = VSHelper.GetAllProjectItems();
GlobalContainer.ProjectTypes = VSHelper.GetAllTypes(GlobalContainer.ProjectItems);
GlobalContainer.Settings = XmlSettings.Load(VSHelper.Host.TemplateFile + ".settings.xml");
GlobalContainer.KnownNamespaces = new HashSet<string>
    {
        "System",
        "System.Collections.Generic",
        "System.ComponentModel",
        "System.CodeDom.Compiler",
        "System.Linq",
        "System.Linq.Expressions",
        "System.Reflection",
        "FluentNHibernate.Automapping",
        "FluentNHibernate.Mapping",
    };
if (GlobalContainer.Settings.GenerateMetadata.Relations)
    GlobalContainer.KnownNamespaces.Add("T4FluentNH.Metadata");

if (GlobalContainer.Settings.AsyncMethods)
{
    GlobalContainer.KnownNamespaces.Add("NHibernate");
    GlobalContainer.KnownNamespaces.Add("NHibernate.Collection");
    GlobalContainer.KnownNamespaces.Add("NHibernate.Util");
    GlobalContainer.KnownNamespaces.Add("System.Threading.Tasks");
}

if(GlobalContainer.Settings.WasModified)
    VSHelper.Warning("T4FluentNH settings was modified");


if (debug)
{
    stepWatch.Stop();
    VSHelper.Warning("Setting Global container: " + stepWatch.ElapsedMilliseconds);    
}


/*TODOS*/
//TODO: Strict - do note that non public getter or setter are not serialized/deserialized by default with Json.net

#region Overrides
if (debug) 
    stepWatch = Stopwatch.StartNew(); 

//Get and save all overrides
VSHelper.ProcessFiles(GlobalContainer.ProjectItems, (file, name) => VSHelper.ProcessTypes(file, (type, pItem) => 
    {
        if (VSHelper.GetAttribute(type.Attributes, "System.CodeDom.Compiler.GeneratedCodeAttribute") != null)
        {
            if (!GlobalContainer.EntityProjectItems.ContainsKey(type.FullName))
                GlobalContainer.EntityProjectItems.Add(type.FullName, new EntityProjectItem(type.FullName));
            GlobalContainer.EntityProjectItems[type.FullName].SetGeneratedFile(pItem);
            return;
        }
        if( VSHelper.IsDerivedFrom(type, GlobalContainer.Settings.BaseEntityType) && !GlobalContainer.Settings.IgnoreTypes.Contains(type.FullName))
        {
            if (!GlobalContainer.EntityProjectItems.ContainsKey(type.FullName))
                GlobalContainer.EntityProjectItems.Add(type.FullName, new EntityProjectItem(type.FullName));
            GlobalContainer.EntityProjectItems[type.FullName].AddEntityFile(pItem);

            GlobalContainer.DomainProjectItems.Add(pItem);

            return;
        }
        var mapOverride =
            type.ImplementedInterfaces.OfType<CodeElement>()
                .FirstOrDefault(o => o.FullName.Contains("IAutoMappingOverride"));

        if(mapOverride == null) return;
        var overrideType = VSHelper.GetGenericAgruments(mapOverride.FullName)[0];
        if(overrideType == null) return;

        //get override method
        var method = VSHelper.GetMethod(type, "Override");
        if(method == null) return;

        if (!GlobalContainer.Overrides.ContainsKey(overrideType))
        {
            var entityOverride = new EntityOverride
            {
                Class = type,
                OverrideMethod = method,
                OverrideType = overrideType
            };
            GlobalContainer.Overrides.Add(overrideType, entityOverride);
        }
            

        //VSHelper.Warning("Overrides found for type " + overrideType);

        if (!GlobalContainer.EntityProjectItems.ContainsKey(overrideType))
            GlobalContainer.EntityProjectItems.Add(overrideType, new EntityProjectItem(type.FullName));

        GlobalContainer.EntityProjectItems[overrideType].AddOverrideFile(pItem);

    }));

foreach (var pair in GlobalContainer.Overrides.ToList()) // clone as the collection will be modified
{
    var overrideType = pair.Key;
    var entityOverride = pair.Value;
    
    EntityType entityType = null;

    //Get properties for overriden type
    var properties = new Dictionary<string, CodeProperty>();
    foreach(var partialType in GlobalContainer.ProjectTypes[overrideType])
    {
        if (entityType == null)
            entityType = GlobalContainer.Settings.GetEntityType(VSHelper, partialType, false);

        foreach (var p in VSHelper.GetProperties(partialType))
        {
            if(properties.ContainsKey(p.Name))
                throw new Exception(string.Format("Duplicate property {0} inside type {1}", p.Name, partialType.FullName));
            properties.Add(p.Name, p);
        }
                
    }

    if(entityType == null)
        throw new Exception("EntityType for type " + overrideType + " does not exists");

    if (entityOverride.OverrideMethod == null)
        continue;

    var functionText = VSHelper.GetCodeFunctionText(entityOverride.OverrideMethod);
        
    //Components
    var compRegex = new Regex(@"\.Component\([\w\s]+=>[\s\w]+\.([\w\d]+)");
    var compMatches = compRegex.Matches(functionText);
    foreach (var match in compMatches.OfType<Match>().Where(o => o.Success))
    {
        var propName = match.Groups[1].Value;
        if(!properties.ContainsKey(propName)) continue;
        var prop = properties[propName];
        if(prop == null) throw new Exception("prop null");
        if(!GlobalContainer.Components.ContainsKey(overrideType))
            GlobalContainer.Components.Add(overrideType, new Dictionary<string, CodeProperty>());
        GlobalContainer.Components[overrideType].Add(propName, prop);
    }

    //oneToMany relation
    var oneToManyRegex = new Regex(@"\.HasMany\([\w\s]+=>[\s\w]+\.([\w\d]+)\)([^;]*)");
    var oneToManyMatches = oneToManyRegex.Matches(functionText);
    foreach(var match in oneToManyMatches.OfType<Match>().Where(o => o.Success))
    {
        var propName = match.Groups[1].Value;
        var extraCalls = match.Groups[2].Value;
        if(!properties.ContainsKey(propName)) continue;
        var prop = properties[propName];
        if(prop == null) throw new Exception("prop null");
        var relatedPropType = VSHelper.GetGenericAgruments(prop.Type).First();
        if(relatedPropType == null) throw new Exception("relatedPropType null");

        var relatedPropName = "";
        var keyColumn = "";

        //KeyColumn - support KeyColumn(o => o.Category) or KeyColumn("CategoryId")
        var keyColumnRegex = new Regex(@"\.KeyColumn\([\w\s]+=>[\s\w]+\.([\w\d]+)\)|\.KeyColumn\(""([\w\d]+)""\)");
        var keyColumnMatches = keyColumnRegex.Matches(extraCalls);
        foreach (var keyColumnMatch in keyColumnMatches.OfType<Match>().Where(o => o.Success))
        {
            if (!string.IsNullOrEmpty(keyColumnMatch.Groups[1].Value)) // if an expression if found then the value is the name of the related property (not fk)
            {
                keyColumn = entityType.KeyColumnPrefix + keyColumnMatch.Groups[1].Value + entityType.KeyColumnPostfix;
                relatedPropName = keyColumnMatch.Groups[1].Value;
            }
            else
            {
                keyColumn = keyColumnMatch.Groups[2].Value;
                // check if the key column is a string with the right convention
                if (
                    (string.IsNullOrEmpty(entityType.KeyColumnPrefix) || keyColumn.StartsWith(entityType.KeyColumnPrefix)) &&
                    (string.IsNullOrEmpty(entityType.KeyColumnPostfix) || keyColumn.EndsWith(entityType.KeyColumnPostfix))
                    )
                {
                    relatedPropName = VSHelper.Trim(keyColumn, entityType.KeyColumnPrefix, entityType.KeyColumnPostfix);
                }
                else
                {
                    // we need to find out on which property the column is mapped
                    if (!GlobalContainer.Overrides.ContainsKey(relatedPropType))
                    {
                        continue; // Unidirectional relation
                    }
                    var relatedOverride = GlobalContainer.Overrides[relatedPropType];
                    var relatedOverrideMethodText = VSHelper.GetCodeFunctionText(relatedOverride.OverrideMethod);
                    var relatedPropRegex = new Regex(string.Format(@".References\([\w\s]+=>[\s\w]+\.([\w\d]+)\)([^;]*).Column\(""{0}""\)", keyColumn));
                    var realtedPropMatches = relatedPropRegex.Matches(relatedOverrideMethodText).OfType<Match>().Where(o => o.Success).ToList();
                    if (!realtedPropMatches.Any())
                    {
                        throw new Exception(string.Format("Could not find the releated property whitin type '{0}' that should be mapped as column '{1}'", relatedPropType, keyColumn));
                    }
                    if (realtedPropMatches.Count > 1)
                    {
                        throw new Exception(string.Format("There are more than one releated properties whitin type '{0}' that are mapped as column '{1}'", relatedPropType, keyColumn));
                    }
                    relatedPropName = realtedPropMatches.First().Groups[1].Value;
                    keyColumn = entityType.KeyColumnPrefix + relatedPropName + entityType.KeyColumnPostfix;
                }
            }
        }

        //PropertyRef - support PropertyRef(o => o.Category) or PropertyRef("CategoryId")
        var propRefRegex = new Regex(@"\.PropertyRef\([\w\s]+=>[\s\w]+\.([\w\d]+)\)|\.PropertyRef\(""([\w\d]+)""\)");
        var propRefMatches = propRefRegex.Matches(extraCalls);
        foreach (var propRefMatch in propRefMatches.OfType<Match>().Where(o => o.Success))
        {
            relatedPropName = !string.IsNullOrEmpty(propRefMatch.Groups[1].Value)
                ? propRefMatch.Groups[1].Value
                : propRefMatch.Groups[2].Value;
        }

        if (string.IsNullOrEmpty(relatedPropName)) continue;

        //CollectionType - support AsBag(), AsList(), AsSet
        var collTypeRegex = new Regex(@"\.(AsList|AsSet|AsBag)");
        var collTypeMatches = collTypeRegex.Matches(extraCalls);
        var colType = CollectionMapType.Unknown;
        foreach (var collTypeMatch in collTypeMatches.OfType<Match>().Where(o => o.Success))
        {
            var cType = collTypeMatch.Groups[1].Value;
            switch(cType)
            {
                case "AsSet":
                    colType = CollectionMapType.Set;
                    break;
                case "AsList":
                    colType = CollectionMapType.List;
                    break;
                case "AsBag":
                    colType = CollectionMapType.Bag;
                    break;
            }
        }

        var relatedProp = VSHelper.GetProperties(GlobalContainer.ProjectTypes[relatedPropType], true).FirstOrDefault(o => o.Name == relatedPropName);
        var assocType = relatedProp == null ? AssociationType.Unidirectional : AssociationType.Bidirectional;
            
        //Add oneToMany
        GlobalContainer.Overrides[overrideType].Relations[propName] =
            new OneToManyModelRelation
                    {
                        RelatedModelTypeFullName =relatedPropType,
                        CollectionType = VSHelper.GetPropertyType(prop),
                        CollectionMapType = colType,
                        Property = prop, //many
                        KeyColumn = keyColumn,
                        PathInRelatedModel = relatedProp == null ? null : relatedPropName, //one
                        AssociationType = assocType
                    };

        //Add manyToOne
        var manyToOneRelation = new ManyToOneModelRelation
        {
            RelatedModelTypeFullName = overrideType,
            Property = relatedProp,
            KeyColumn = keyColumn,
            PathInRelatedModel = propName,
            AssociationType = assocType
        };

        if (relatedProp == null) //Unidirectional association
        {
            GlobalContainer.AddGlobalModelRelation(relatedPropType, manyToOneRelation);
        }
        else
        {
            if(!GlobalContainer.Overrides.ContainsKey(relatedPropType))
                GlobalContainer.Overrides.Add(relatedPropType, new EntityOverride());
            GlobalContainer.Overrides[relatedPropType].Relations[relatedPropName] = manyToOneRelation;
        }

    }

    //oneToOne relation
    var oneToOneRegex = new Regex(@"\.HasOne\([\w\s]+=>[\s\w]+\.([\w\d]+)\)([^;]*)");
    var oneToOneMatches = oneToOneRegex.Matches(functionText);
    foreach(var match in oneToOneMatches.OfType<Match>().Where(o => o.Success))
    {
        var propName = match.Groups[1].Value;
        var extraCalls = match.Groups[2].Value;
        var prop = properties[propName];
        if(prop == null) throw new Exception("prop null");
        var relatedPropType = prop.Type.CodeType.FullName;

        //PropertyRef - support PropertyRef(o => o.Category) or PropertyRef("CategoryId")
        var propRefRegex = new Regex(@"\.PropertyRef\([\w\s]+=>[\s\w]+\.([\w\d]+)\)|\.PropertyRef\(""([\w\d]+)""\)");
        var propRefMatches = propRefRegex.Matches(extraCalls);
        var relatedPropName = "";
        foreach (var propRefMatch in propRefMatches.OfType<Match>().Where(o => o.Success))
        {
            relatedPropName = !string.IsNullOrEmpty(propRefMatch.Groups[1].Value)
                ? propRefMatch.Groups[1].Value
                : propRefMatch.Groups[2].Value;
        }
        if (string.IsNullOrEmpty(relatedPropName)) continue;
        var relatedProp = VSHelper.GetProperties(GlobalContainer.ProjectTypes[relatedPropType]).First(o => o.Name == relatedPropName);

        //Add oneToOne
        GlobalContainer.Overrides[overrideType].Relations[propName] =
            new OneToOneModelRelation
                    {
                        RelatedModelTypeFullName = relatedPropType,
                        Property = prop, 
                        PathInRelatedModel = relatedPropName ,
                        AssociationType = AssociationType.Bidirectional
                    };
        //Add one to one
        if(!GlobalContainer.Overrides.ContainsKey(relatedPropType))
            GlobalContainer.Overrides.Add(relatedPropType, new EntityOverride());

        if(!GlobalContainer.Overrides[relatedPropType].Relations.ContainsKey(relatedPropName)) //if is not self related
        {
            GlobalContainer.Overrides[relatedPropType].Relations.Add(relatedPropName,
            new OneToOneModelRelation
                    {
                        RelatedModelTypeFullName = overrideType,
                        Property = relatedProp, 
                        PathInRelatedModel = propName,
                        AssociationType = AssociationType.Bidirectional
                    });
        }
    }

    //manyToMany relation
    var manyToManyRegex = new Regex(@"\.HasManyToMany\([\w\s]+=>[\s\w]+\.([\w\d]+)\)");
    var manyToManyMatches = manyToManyRegex.Matches(functionText);
    foreach(Match match in manyToManyMatches)
    {
        if (!match.Success) continue;
        var propName = match.Groups[1].Value;
        var prop = properties[propName];
        if(prop == null) throw new Exception("prop null");
        var relatedPropType = VSHelper.GetGenericAgruments(prop.Type).First();

        foreach(var relPartialType in GlobalContainer.ProjectTypes[relatedPropType])
        {
            foreach(var relTypeProp in VSHelper.GetProperties(relPartialType))
            {
                //VSHelper.Warning(type.FullName + " - " +overrideType + " - " + relTypeProp.Name +" - "+ VSHelper.GetGenericAgruments(relTypeProp.Type).FirstOrDefault());
                if(
                    VSHelper.IsNHibernateProperty(relTypeProp) &&
                    VSHelper.IsGeneric(relTypeProp.Type) &&
                    VSHelper.GetGenericAgruments(relTypeProp.Type).FirstOrDefault() == overrideType &&
                    !GlobalContainer.Overrides[overrideType].Relations.ContainsKey(propName))
                {
                    //add manyToMany
                    GlobalContainer.Overrides[overrideType].Relations[propName] =
                        new ManyToManyModelRelation
                                {
                                    RelatedModelTypeFullName = relatedPropType,
                                    CollectionType = VSHelper.GetPropertyType(prop),
                                    Property = prop, 
                                    PathInRelatedModel = relTypeProp.Name,
                                    AssociationType = AssociationType.Bidirectional
                                };
                }    
            }
        }

            
    }
} // end forech overrides

#endregion

if (debug)
{
    stepWatch.Stop();
    VSHelper.Warning("Process overrides: " + stepWatch.ElapsedMilliseconds);
    stepWatch = Stopwatch.StartNew(); 
}

var manager = Manager.Create(Host, GenerationEnvironment);

VSHelper.ProcessFiles(GlobalContainer.DomainProjectItems, (file, name) => 
    VSHelper.ProcessTypes(file, (type, pItem) => 
        {
            if(VSHelper.GetAttribute(type.Attributes, "System.CodeDom.Compiler.GeneratedCodeAttribute") != null) return;
            //VSHelper.GetAllCodeElementsOfType(type.)
            if(!VSHelper.IsDerivedFrom(type, GlobalContainer.Settings.BaseEntityType) || GlobalContainer.Settings.IgnoreTypes.Contains(type.FullName)) return;
            //VSHelper.Warning(pItem.get_FileNames(0) + " gener created: " + (GlobalContainer.GeneratedFiles.ContainsKey(type.FullName) ?  File.GetCreationTime(GlobalContainer.GeneratedFiles[type.FullName]).ToString() : "WTF") + " gener modif: " + (GlobalContainer.GeneratedFiles.ContainsKey(type.FullName) ?  File.GetLastWriteTime(GlobalContainer.GeneratedFiles[type.FullName]).ToString() : "WTF") + " real: " + File.GetLastWriteTime(pItem.get_FileNames(0)));
            
            var entityPItem = GlobalContainer.EntityProjectItems[type.FullName];
            var domainModelModified = entityPItem.IsDirty();

            if (domainModelModified)
            {
                VSHelper.Warning(string.Format("Type '{0}' was modified", type.FullName));
            }

            if (!domainModelModified && !GlobalContainer.Settings.WasModified)
            {
                manager.KeepGeneratedFile(entityPItem.GeneratedFileAbsoultePath);
            }

            var domainClass = new DomainModelWrapper
            {
                CodeClass = type,
                ProjectItem = pItem,
                WasModified = domainModelModified,
                SettingsXml = entityPItem.Serialize()
            };

            if(!GlobalContainer.DomainClasses.ContainsKey(type.FullName))
                GlobalContainer.DomainClasses.Add(type.FullName, domainClass);
            else
                GlobalContainer.DomainClasses[type.FullName].Merge(domainClass);
            //Warning(string.Format("Processing type: '{0}' with parameter WasModified = {1}", type.FullName, domainModelModified));
        }));

if (debug)
{
    stepWatch.Stop();
    VSHelper.Warning("Filling domian classes: " + stepWatch.ElapsedMilliseconds);
    stepWatch = Stopwatch.StartNew();
}

//Initialize All DomainClasses
foreach (var domainClass in GlobalContainer.DomainClasses.Where(o => o.Value.WasModified || GlobalContainer.Settings.WasModified))
{
    
    var typeWatch = debug ? Stopwatch.StartNew() : null; 
    domainClass.Value.Initialize();

    if (debug)
    {
        typeWatch.Stop();
        VSHelper.Warning("Initializing domian class: " + domainClass.Value.FileName + ", Time: " + typeWatch.ElapsedMilliseconds);
    }
    
}
if (debug)
{
    stepWatch.Stop();
    VSHelper.Warning("Initializing domian classes: " + stepWatch.ElapsedMilliseconds);
}

manager.StartHeader(); 
#>
//----------------------
// <auto-generated>
//    Generated by T4FluentNH.
// </auto-generated>
//----------------------
// ReSharper disable All
<#
foreach (var ns in GlobalContainer.KnownNamespaces)
{
#>
using <#=ns#>;
<#
}
manager.EndBlock(); 

foreach(var type in GlobalContainer.DomainClasses.Values.Where(o => o.WasModified || GlobalContainer.Settings.WasModified))
{
    manager.StartNewFile(string.Format("{0}.generated.cs", type.FileName)); 
#>
//<#=type.SettingsXml#>
namespace <#=type.Namespace.FullName#>
{
    [GeneratedCode("T4Template", "1.0")]
    public partial class <#=type.FullClassName#>
    {

<#
    if (GlobalContainer.Settings.GenerateMetadata.Relations)
    {
#>
        #region RelationsMetadata
        #pragma warning disable

        public new static readonly Dictionary<string, RelationMetadata> RelationsMetadata =
            new Dictionary<string, RelationMetadata>
            {
<#
        foreach (var relation in type.RelatedModels.Where(o => o.Property != null))
        {
            switch (relation.Type)
            {
                case ModelRelationType.OneToMany:
                case ModelRelationType.ManyToMany:
                    var collectionRelation = (CollectionModelRelation)relation;
                    var classPrefix = ModelRelationType.OneToMany == relation.Type
                        ? "OneToMany"
                        : "ManyToMany";
#>
                {"<#=relation.PropertyName #>", new <#=classPrefix #>RelationMetadata
                {
                    RelatedModelType = typeof(<#=relation.RelatedModelTypeName#>),
<#
                    if (!string.IsNullOrEmpty(relation.PathInRelatedModel))
                    {
#>
                    RelatedModelProperty = typeof(<#=relation.RelatedModelTypeName#>).GetProperty("<#=relation.PathInRelatedModel#>"),
<#
                    }
#>
                    RelatedModelIdProperty = typeof(<#=relation.RelatedModelTypeName#>).GetProperty("<#=relation.RelatedModelIdPropertyName#>"),
                    AssociationType = AssociationType.<#=relation.AssociationType#>,
                    Field = typeof(<#=type.FullClassName#>).GetField("<#=relation.FieldName#>", BindingFlags.Instance | BindingFlags.NonPublic),
                    ParameterName = "<#=relation.ParameterName#>",
                    Property = typeof(<#=type.FullClassName#>).GetProperty("<#=relation.PropertyName#>"),
<#
                    if (relation.AssociationType == AssociationType.Bidirectional)
                    {
#>
                    AddMethod = typeof(<#=type.FullClassName#>).GetMethods().FirstOrDefault(o => o.Name == "<#=collectionRelation.AddMethodName#>" && o.GetParameters().Length == 1 && o.GetParameters()[0].ParameterType == typeof(<#=collectionRelation.RelatedModelTypeName#>)),
                    RemoveMethod = typeof(<#=type.FullClassName#>).GetMethods().FirstOrDefault(o => o.Name == "<#=collectionRelation.RemoveMethodName#>" && o.GetParameters().Length == 1 && o.GetParameters()[0].ParameterType == typeof(<#=collectionRelation.RelatedModelTypeName#>)),
<#
                    }
#>
                    CollectionMapType = CollectionMapType.<#=collectionRelation.CollectionMapType.ToString()#>,
                    
                }},
        
<#
                    break;
                case ModelRelationType.OneToOne:
                case ModelRelationType.ManyToOne:
                    var oneRelation = (OneModelRelation)relation;
                    var manyToOneRelation = relation as ManyToOneModelRelation;
                    var oneClassPrefix = ModelRelationType.OneToOne == relation.Type
                        ? "OneToOne"
                        : "ManyToOne";
#>
                {"<#=relation.PropertyName #>", new <#=oneClassPrefix #>RelationMetadata
                {
                    RelatedModelType = typeof(<#=relation.RelatedModelTypeName#>),
<#
                    if (!string.IsNullOrEmpty(relation.PathInRelatedModel))
                    {
#>
                    RelatedModelProperty = typeof(<#=relation.RelatedModelTypeName#>).GetProperty("<#=relation.PathInRelatedModel#>"),
<#
                    }
#>
                    RelatedModelIdProperty = typeof(<#=relation.RelatedModelTypeName#>).GetProperty("<#=relation.RelatedModelIdPropertyName#>"),
                    AssociationType = AssociationType.<#=relation.AssociationType#>,
                    Field = typeof(<#=type.FullClassName#>).GetField("<#=relation.FieldName#>", BindingFlags.Instance | BindingFlags.NonPublic),
                    ParameterName = "<#=relation.ParameterName#>",
                    Property = typeof(<#=type.FullClassName#>).GetProperty("<#=relation.PropertyName#>"),
<#
                    if (relation.AssociationType == AssociationType.Bidirectional)
                    {
#>
                    SetMethod = typeof(<#=type.FullClassName #>).GetMethods().FirstOrDefault(o => o.Name == "<#=oneRelation.SetMethodName #>" && o.GetParameters().Length == 1 && o.GetParameters()[0].ParameterType == typeof(<#=oneRelation.RelatedModelTypeName #>)),
                    UnsetMethod = typeof(<#=type.FullClassName #>).GetMethods().FirstOrDefault(o => o.Name == "<#=oneRelation.UnsetMethodName #>" && o.GetParameters().Length == 0),
<#
                    }
                    if (!string.IsNullOrEmpty(oneRelation.SyntheticPropertyName))
                    {
#>
                    SyntheticProperty = typeof(<#=type.FullClassName#>).GetProperty("<#=oneRelation.SyntheticPropertyName#>"),
                    SyntheticField = typeof(<#=type.FullClassName#>).GetField("<#=oneRelation.SyntheticFieldName#>", BindingFlags.Instance | BindingFlags.NonPublic),
                    SyntheticPropertyMaxLength = <#=(string.IsNullOrEmpty(oneRelation.SyntheticPropertyMaxLength) ? "null" : oneRelation.SyntheticPropertyMaxLength)#>,
                    IsSyntheticPropertyTypeRequired = <#=(oneRelation.IsSyntheticPropertyTypeRequired ? "true" : "false")#>,
<#
                    }
                    if (manyToOneRelation != null && !string.IsNullOrEmpty(manyToOneRelation.RelatedTypeRemoveMethodName))
                    {
#>
                    RelatedModelRemoveMethod = typeof(<#=relation.RelatedModelTypeName#>).GetMethods().FirstOrDefault(o => o.Name == "<#=manyToOneRelation.RelatedTypeRemoveMethodName#>" && o.GetParameters().Length == 1 && o.GetParameters()[0].ParameterType == typeof(<#=type.FullClassName#>)),
<#
                    }
#>                    
                }},
        
<#
                    break;
            }
        }
#>
            };
        #pragma warning restore
        #endregion

<#
    }
    if (GlobalContainer.Components.ContainsKey(type.FullName))
    {
#>
        #region Components fileds
<#
        foreach (var comp in GlobalContainer.Components[type.FullName])
        {
#>
        private <#=comp.Value.Type.AsFullName#> <#=VSHelper.GetFieldName(comp.Key)#>;
<#
        }
#>
        #endregion
<#
    }
#>
<#
    foreach(var relation in type.RelatedModels)
    {
#>
        #region <#=relation.PropertyName#>

<#
        switch(relation.Type)
        {
            case ModelRelationType.OneToMany:
                var oneToManyRelation = (OneToManyModelRelation) relation;
#>
        private <#=oneToManyRelation.FieldCollectionType#> <#=oneToManyRelation.FieldName#>;
<#
                if (relation.AssociationType == AssociationType.Bidirectional)
                {
                    if (!oneToManyRelation.ExistsAddMethod)
                    {
#>

        public virtual void <#=oneToManyRelation.AddMethodName #>(<#=oneToManyRelation.RelatedModelTypeName #> <#=oneToManyRelation.ParameterName #>)
        {
            this.AddOneToMany(o => o.<#=relation.PropertyName #>, <#=oneToManyRelation.ParameterName #>, o => o.<#=relation.PathInRelatedModel #>, o=> o.<#=oneToManyRelation.RemoveMethodName #>);
        }
<#
                    }
                    if(GlobalContainer.Settings.AsyncMethods && !oneToManyRelation.ExistsAddAsyncMethod)
                    {
#>

        public virtual Task <#=oneToManyRelation.AddMethodName #>Async(<#=oneToManyRelation.RelatedModelTypeName #> <#=oneToManyRelation.ParameterName #>)
        {
            return this.AddOneToManyAsync(o => o.<#=relation.PropertyName #>, <#=oneToManyRelation.ParameterName #>, o => o.<#=relation.PathInRelatedModel #>, o=> o.<#=oneToManyRelation.RemoveMethodName #>Async);
        }
<#
                    }
                    if (!oneToManyRelation.ExistsRemoveMethod)
                    {
#>

        public virtual void <#=oneToManyRelation.RemoveMethodName #>(<#=oneToManyRelation.RelatedModelTypeName #> <#=oneToManyRelation.ParameterName #>)
        {
            this.RemoveOneToMany(o => o.<#=relation.PropertyName #>, <#=oneToManyRelation.ParameterName #>, o => o.<#=relation.PathInRelatedModel #>);
        }
<#
                    }
                    if(GlobalContainer.Settings.AsyncMethods && !oneToManyRelation.ExistsRemoveAsyncMethod)
                    {
#>

        public virtual Task <#=oneToManyRelation.RemoveMethodName #>Async(<#=oneToManyRelation.RelatedModelTypeName #> <#=oneToManyRelation.ParameterName #>)
        {
            return this.RemoveOneToManyAsync(o => o.<#=relation.PropertyName #>, <#=oneToManyRelation.ParameterName #>, o => o.<#=relation.PathInRelatedModel #>);
        }
<#
                    }
                }
                break;
            case ModelRelationType.ManyToMany:
                var manyToManyRelation = (ManyToManyModelRelation) relation;
#>
        private <#=manyToManyRelation.FieldCollectionType#> <#=manyToManyRelation.FieldName#>;
<#
                if (relation.AssociationType == AssociationType.Bidirectional)
                {
                    if (!manyToManyRelation.ExistsAddMethod)
                    {
#>
        public virtual void <#=manyToManyRelation.AddMethodName#>(<#=manyToManyRelation.RelatedModelTypeName#> <#=manyToManyRelation.ParameterName#>)
        {
            this.AddManyToMany(o => o.<#=relation.PropertyName #>, <#=manyToManyRelation.ParameterName #>, o => o.<#=relation.PathInRelatedModel #>);
        }
<#
                    }
                    if (GlobalContainer.Settings.AsyncMethods && !manyToManyRelation.ExistsAddAsyncMethod)
                    {
#>
        public virtual Task <#=manyToManyRelation.AddMethodName#>Async(<#=manyToManyRelation.RelatedModelTypeName#> <#=manyToManyRelation.ParameterName#>)
        {
            return this.AddManyToManyAsync(o => o.<#=relation.PropertyName #>, <#=manyToManyRelation.ParameterName #>, o => o.<#=relation.PathInRelatedModel #>);
        }
<#
                    }
                    if (!manyToManyRelation.ExistsRemoveMethod)
                    {
#>

        public virtual void <#=manyToManyRelation.RemoveMethodName #>(<#=manyToManyRelation.RelatedModelTypeName #> <#=manyToManyRelation.ParameterName #>)
        {
            this.RemoveManyToMany(o => o.<#=relation.PropertyName #>, <#=manyToManyRelation.ParameterName #>, o => o.<#=relation.PathInRelatedModel #>);
        }
<#
                    }
                    if (GlobalContainer.Settings.AsyncMethods && !manyToManyRelation.ExistsRemoveAsyncMethod)
                    {
#>

        public virtual Task <#=manyToManyRelation.RemoveMethodName #>Async(<#=manyToManyRelation.RelatedModelTypeName #> <#=manyToManyRelation.ParameterName #>)
        {
            return this.RemoveManyToManyAsync(o => o.<#=relation.PropertyName #>, <#=manyToManyRelation.ParameterName #>, o => o.<#=relation.PathInRelatedModel #>);
        }
<#
                    }
                }
                break;
            case ModelRelationType.ManyToOne:
                var manyToOneRelation = (ManyToOneModelRelation) relation;
                if (manyToOneRelation.GenerateSyntheticProperty)
                {
#>
        private <#=relation.RelatedModelTypeName#> <#=relation.FieldName#>;

<#  
                    foreach (var attr in GlobalContainer.Settings.SyntheticProperties.CustomAttributes)
                    {
#>
        [<#=attr#>]
<#                       
                    }
                    if (manyToOneRelation.IsSyntheticPropertyTypeRequired && !string.IsNullOrEmpty(GlobalContainer.Settings.NotNullAttribute) && GlobalContainer.Settings.SyntheticProperties.AddNotNullAttribute)
                    {
#>
        [<#=GlobalContainer.Settings.NotNullAttribute#>]
<#
                    }
                    if (!string.IsNullOrEmpty(manyToOneRelation.SyntheticPropertyMaxLength) && !string.IsNullOrEmpty(GlobalContainer.Settings.LengthAttribute) && GlobalContainer.Settings.SyntheticProperties.AddLengthAttribute)
                    {
#>
        [<#=GlobalContainer.Settings.LengthAttribute#>(<#=manyToOneRelation.SyntheticPropertyMaxLength#>)]
<#
                    }
                    if(relation.Property == null)
                    {
#>
        public virtual <#=manyToOneRelation.SyntheticPropertyTypeName#> <#=manyToOneRelation.SyntheticPropertyName#> { get; <#=GlobalContainer.Settings.Strict ? "protected " : ""#>set; }
<#
                    }
                    else
                    {
#>
        public virtual <#=manyToOneRelation.SyntheticPropertyTypeName#> <#=manyToOneRelation.SyntheticPropertyName#> 
        {
            get 
            {
                if(<#=manyToOneRelation.SyntheticIsSetFieldName#>) return <#=manyToOneRelation.SyntheticFieldName#>;
                return <#=manyToOneRelation.PropertyName#> == null ? default(<#=manyToOneRelation.SyntheticPropertyTypeName#>) : <#=manyToOneRelation.PropertyName#>.<#=manyToOneRelation.RelatedModelIdPropertyName#>;
            }
            <#=GlobalContainer.Settings.Strict ? "protected " : ""#>set 
            {
                <#=manyToOneRelation.SyntheticIsSetFieldName#> = true;
                <#=manyToOneRelation.SyntheticFieldName#> = value; 
            }
        }

        private <#=manyToOneRelation.SyntheticPropertyTypeName#> <#=manyToOneRelation.SyntheticFieldName#>;

        private bool <#=manyToOneRelation.SyntheticIsSetFieldName#> = false;
<#
                    }    
                }
                if (relation.AssociationType == AssociationType.Bidirectional)
                {
                    if(GlobalContainer.Settings.AsyncMethods && !manyToOneRelation.ExistsSetAsyncMethod)
                    {
#>

        public virtual Task <#=manyToOneRelation.SetMethodName #>Async(<#=manyToOneRelation.RelatedModelTypeName #> <#=manyToOneRelation.ParameterName #>)
        {
            return this.SetManyToOneAsync(o => o.<#=manyToOneRelation.PropertyName #>, <#=manyToOneRelation.ParameterName #>, o => o.<#=manyToOneRelation.RelatedTypeRemoveMethodName#>Async, o => o.<#=relation.PathInRelatedModel #>);
        }
<#
                    }
                    if(!manyToOneRelation.ExistsSetMethod)
                    {
#>

        public virtual void <#=manyToOneRelation.SetMethodName #>(<#=manyToOneRelation.RelatedModelTypeName #> <#=manyToOneRelation.ParameterName #>)
        {
            this.SetManyToOne(o => o.<#=manyToOneRelation.PropertyName #>, <#=manyToOneRelation.ParameterName #>, o => o.<#=manyToOneRelation.RelatedTypeRemoveMethodName#>, o => o.<#=relation.PathInRelatedModel #>);
        }
<#
                    }
                    if (!manyToOneRelation.ExistsUnsetMethod)
                    {
#>

        public virtual void <#=manyToOneRelation.UnsetMethodName #>()
        {
            this.UnsetManyToOne(o => o.<#=manyToOneRelation.PropertyName #>, o => o.<#=relation.PathInRelatedModel #>);
        }
<#
                    }
                    if (GlobalContainer.Settings.AsyncMethods && !manyToOneRelation.ExistsUnsetAsyncMethod)
                    {
#>

        public virtual Task <#=manyToOneRelation.UnsetMethodName #>Async()
        {
            return this.UnsetManyToOneAsync(o => o.<#=manyToOneRelation.PropertyName #>, o => o.<#=relation.PathInRelatedModel #>);
        }
<#
                    }
                }
                break;
            case ModelRelationType.OneToOne:
                var oneToOneRelation = (OneToOneModelRelation) relation;
                if (oneToOneRelation.GenerateSyntheticProperty)
                {
#>
        private <#=relation.RelatedModelTypeName#> <#=relation.FieldName#>;

<#  
                    foreach (var attr in GlobalContainer.Settings.SyntheticProperties.CustomAttributes)
                    {
#>
        [<#=attr#>]
<#                       
                    }
                    if (oneToOneRelation.IsSyntheticPropertyTypeRequired && !string.IsNullOrEmpty(GlobalContainer.Settings.NotNullAttribute) && GlobalContainer.Settings.SyntheticProperties.AddNotNullAttribute)
                    {
#>
        [<#=GlobalContainer.Settings.NotNullAttribute#>]
<#
                    }
                    if (!string.IsNullOrEmpty(oneToOneRelation.SyntheticPropertyMaxLength) && !string.IsNullOrEmpty(GlobalContainer.Settings.LengthAttribute) && GlobalContainer.Settings.SyntheticProperties.AddLengthAttribute)
                    {
#>
        [<#=GlobalContainer.Settings.LengthAttribute#>(<#=oneToOneRelation.SyntheticPropertyMaxLength#>)]
<#
                    }
                    if(relation.Property == null)
                    {
#>
        public virtual <#=oneToOneRelation.SyntheticPropertyTypeName#> <#=oneToOneRelation.SyntheticPropertyName#> { get; <#=GlobalContainer.Settings.Strict ? "protected " : ""#>set; }
<#
                    }
                    else
                    {
#>
        public virtual <#=oneToOneRelation.SyntheticPropertyTypeName#> <#=oneToOneRelation.SyntheticPropertyName#> 
        { 
            get
            {
                if(<#=oneToOneRelation.SyntheticIsSetFieldName#>) return <#=oneToOneRelation.SyntheticFieldName#>;
                return <#=oneToOneRelation.PropertyName#> == null ? default(<#=oneToOneRelation.SyntheticPropertyTypeName#>) : <#=oneToOneRelation.PropertyName#>.<#=oneToOneRelation.RelatedModelIdPropertyName#>;
            }
            <#=GlobalContainer.Settings.Strict ? "protected " : ""#>set 
            {
                <#=oneToOneRelation.SyntheticIsSetFieldName#> = true;
                <#=oneToOneRelation.SyntheticFieldName#> = value; 
            }
        }

        private <#=oneToOneRelation.SyntheticPropertyTypeName#> <#=oneToOneRelation.SyntheticFieldName#>;

        private bool <#=oneToOneRelation.SyntheticIsSetFieldName#> = false;
<#
                    }    
                }
                if (relation.AssociationType == AssociationType.Bidirectional)
                {
                    if(!oneToOneRelation.ExistsSetMethod)
                    {
#>

        public virtual void <#=oneToOneRelation.SetMethodName #>(<#=oneToOneRelation.RelatedModelTypeName #> <#=oneToOneRelation.ParameterName #>)
        {
            this.SetOneToOne(o => o.<#=oneToOneRelation.PropertyName #>, <#=oneToOneRelation.ParameterName #>, o => o.<#=relation.PathInRelatedModel #>);
        }
<#
                    }
                    if(GlobalContainer.Settings.AsyncMethods && !oneToOneRelation.ExistsSetAsyncMethod)
                    {
#>

        public virtual Task <#=oneToOneRelation.SetMethodName #>Async(<#=oneToOneRelation.RelatedModelTypeName #> <#=oneToOneRelation.ParameterName #>)
        {
            return this.SetOneToOneAsync(o => o.<#=oneToOneRelation.PropertyName #>, <#=oneToOneRelation.ParameterName #>, o => o.<#=relation.PathInRelatedModel #>);
        }
<#
                    }
                    if (!oneToOneRelation.ExistsUnsetMethod)
                    {
#>

        public virtual void <#=oneToOneRelation.UnsetMethodName #>()
        {
            this.UnsetOneToOne(o => o.<#=oneToOneRelation.PropertyName #>, o => o.<#=relation.PathInRelatedModel #>);
        }    
<#
                    }
                    if (GlobalContainer.Settings.AsyncMethods && !oneToOneRelation.ExistsUnsetAsyncMethod)
                    {
#>

        public virtual Task <#=oneToOneRelation.UnsetMethodName #>Async()
        {
            return this.UnsetOneToOneAsync(o => o.<#=oneToOneRelation.PropertyName #>, o => o.<#=relation.PathInRelatedModel #>);
        }    
<#
                    }
                }
                break;
        }
#>

        #endregion

<#
    }
    if (GlobalContainer.Settings.SyntheticProperties.Generate)
    {
#>

        private void ResetField<T>(ref T field, T value, ref bool synthIsSetField)
        {
            field = value;
            synthIsSetField = false;
        }
<#  
    }
#>
    }
}
<#
    manager.EndBlock();
}
manager.Process(true);

//reset static props
GlobalContainer.Reset();

globalWatch.Stop();
VSHelper.Warning(string.Format("T4FluentNH finished in {0} ms.", globalWatch.ElapsedMilliseconds)); 


if(GlobalContainer.Settings.ReadOnlyAttributeConvention)
{
#>


using FluentNHibernate.Conventions;
using FluentNHibernate.Conventions.Instances;

namespace T4FluentNH.Conventions
{
    public class ReadOnlyAttributeConvention : AttributePropertyConvention<ReadOnlyAttribute>
    {
        protected override void Apply(ReadOnlyAttribute attribute, IPropertyInstance instance)
        {
            if (attribute.IsReadOnly)
                instance.ReadOnly();
            else
                instance.Not.ReadOnly();
        }
    }
}
<#  
}
#>

namespace T4FluentNH.Attributes
{
    //nhiberante will create a many to one relation but in code the .tt template will generate a one to one relation (in nhibernate one to one on same type will throw an stackoverflow exception!)
    //this attribute is only relevant to .tt template
    internal class AsOneToOneAttribute : Attribute
    {
    }
}


namespace FluentNHibernate.Automapping
{
    internal static class EntityExtensions
    {
<#
    if(GlobalContainer.Settings.AsyncMethods)
    {
#>
        private static Task<bool> ContainsAsync<T>(ICollection<T> collection, T item)
        {
            var persistentCol = collection as IPersistentCollection;
            if (persistentCol == null)
            {
                return Task.FromResult(collection.Contains(item));
            }
            return persistentCol.ContainsAsync(item);
        }

        private static Task AddAsync<T>(ICollection<T> collection, T item)
        {
            var persistentCol = collection as IPersistentCollection;
            if (persistentCol == null)
            {
                collection.Add(item);
                return TaskHelper.CompletedTask;
            }
            return persistentCol.AddAsync(item);
        }

        private static Task RemoveAsync<T>(ICollection<T> collection, T item)
        {
            var persistentCol = collection as IPersistentCollection;
            if (persistentCol == null)
            {
                collection.Remove(item);
                return TaskHelper.CompletedTask;
            }
            return persistentCol.RemoveAsync(item);
        }

        private static async Task AddIfNotExistAsync<T>(ICollection<T> collection, T item)
        {
            var persistentCol = collection as IPersistentCollection;
            if (persistentCol == null)
            {
                AddIfNotExist(collection, item);
                return;
            }
            if (await persistentCol.ContainsAsync(item).ConfigureAwait(false))
            {
                await persistentCol.AddAsync(item).ConfigureAwait(false);
                return;
            }
        }

        private static async Task RemoveIfExistAsync<T>(ICollection<T> collection, T item)
        {
            var persistentCol = collection as IPersistentCollection;
            if(persistentCol == null)
            {
                RemoveIfExist(collection, item);
                return;
            }
            if(await persistentCol.ContainsAsync(item).ConfigureAwait(false))
            {
                await persistentCol.RemoveAsync(item).ConfigureAwait(false);
                return;
            }
        }

        public static async Task AddOneToManyAsync<TOne, TMany>(this TOne one,
            Expression<Func<TOne, IEnumerable<TMany>>> manyListExpr, TMany many,
            Expression<Func<TMany, TOne>> oneExpr,
            Expression<Func<TOne, Func<TMany, Task>>> removeManyExpr)
            where TOne : <#=GlobalContainer.Settings.BaseEntityType#>
            where TMany : <#=GlobalContainer.Settings.BaseEntityType#>
        {
            if (many == null) return;
            if (!NHibernateUtil.IsInitialized(many))
                await NHibernateUtil.InitializeAsync(many).ConfigureAwait(false);
            var enumerable = manyListExpr.Compile()(one);
            var collection = (ICollection<TMany>)enumerable;
            var entityOwnerPropInfo = GetPropertyInfo(many, oneExpr);
            var itemOwner = oneExpr.Compile()(many);
            if (itemOwner != null && !NHibernateUtil.IsInitialized(one))
                await NHibernateUtil.InitializeAsync(itemOwner).ConfigureAwait(false);
            if (await ContainsAsync(collection, many).ConfigureAwait(false)) return;
            if (itemOwner != null)
                await removeManyExpr.Compile()(itemOwner)(many).ConfigureAwait(false);
            entityOwnerPropInfo.SetValue(many, one);
            await AddAsync(collection, many).ConfigureAwait(false);
        }

        public static async Task RemoveOneToManyAsync<TOne, TMany>(this TOne one,
            Expression<Func<TOne, IEnumerable<TMany>>> manyListExpr, TMany many,
            Expression<Func<TMany, TOne>> entityExpr
            )
            where TOne : <#=GlobalContainer.Settings.BaseEntityType#>
            where TMany : <#=GlobalContainer.Settings.BaseEntityType#>
        {
            if (many == null) return;
            if (!NHibernateUtil.IsInitialized(many))
                await NHibernateUtil.InitializeAsync(many).ConfigureAwait(false);
            var enumerable = manyListExpr.Compile()(one);
            var collection = (ICollection<TMany>)enumerable;
            var entityOwnerPropInfo = GetPropertyInfo(many, entityExpr);

            if (!await ContainsAsync(collection, many).ConfigureAwait(false)) return;
            await RemoveAsync(collection, many).ConfigureAwait(false);
            entityOwnerPropInfo.SetValue(many, null);
        }

        public static async Task SetManyToOneAsync<TMany, TOne>(this TMany many,
            Expression<Func<TMany, TOne>> oneExpr, TOne newOne,
            Expression<Func<TOne, Func<TMany, Task>>> removeManyExpr,
            Expression<Func<TOne, IEnumerable<TMany>>> manyExp)
            where TOne : <#=GlobalContainer.Settings.BaseEntityType#>
            where TMany : <#=GlobalContainer.Settings.BaseEntityType#>
        {
            if (newOne == null)
            {
                await many.UnsetManyToOneAsync(oneExpr, manyExp).ConfigureAwait(false);
                return;
            }
            if (!NHibernateUtil.IsInitialized(newOne))
                await NHibernateUtil.InitializeAsync(newOne).ConfigureAwait(false);
            var one = oneExpr.Compile()(many);
            if(one != null && !NHibernateUtil.IsInitialized(one))
                await NHibernateUtil.InitializeAsync(one).ConfigureAwait(false);
            var onePropInfo = GetPropertyInfo(many, oneExpr);
            var manyList = (ICollection<TMany>)manyExp.Compile()(newOne);
            if (Equals(one, newOne)) return;
            if (one != null)
                await removeManyExpr.Compile()(one)(many).ConfigureAwait(false);
            onePropInfo.SetValue(many, newOne);
            await AddIfNotExistAsync(manyList, many).ConfigureAwait(false);
        }

        public static async Task UnsetManyToOneAsync<TMany, TOne>(this TMany many,
            Expression<Func<TMany, TOne>> oneExpr,
            Expression<Func<TOne, IEnumerable<TMany>>> manyListExpr)
            where TOne : <#=GlobalContainer.Settings.BaseEntityType#>
            where TMany : <#=GlobalContainer.Settings.BaseEntityType#>
        {
            var one = oneExpr.Compile()(many);
            if (one == null) return;
            if (!NHibernateUtil.IsInitialized(one))
                await NHibernateUtil.InitializeAsync(one).ConfigureAwait(false);
            var onePropInfo = GetPropertyInfo(many, oneExpr);
            var manyList = (ICollection<TMany>)manyListExpr.Compile()(one);
            await RemoveIfExistAsync(manyList, many).ConfigureAwait(false);
            onePropInfo.SetValue(many, null);
        }

        public static async Task AddManyToManyAsync<TMany, TMany2>(this TMany many,
            Expression<Func<TMany, IEnumerable<TMany2>>> many2ListExpr, TMany2 many2,
            Expression<Func<TMany2, IEnumerable<TMany>>> manyListExpr)
            where TMany : <#=GlobalContainer.Settings.BaseEntityType#>
            where TMany2 : <#=GlobalContainer.Settings.BaseEntityType#>
        {
            if (many2 == null) return;
            if (!NHibernateUtil.IsInitialized(many2))
                await NHibernateUtil.InitializeAsync(many2).ConfigureAwait(false);
            var many2List = (ICollection<TMany2>)many2ListExpr.Compile()(many);
            var manyList = (ICollection<TMany>)manyListExpr.Compile()(many2);
            await AddIfNotExistAsync(manyList, many).ConfigureAwait(false);
            await AddIfNotExistAsync(many2List, many2).ConfigureAwait(false);
        }

        public static async Task RemoveManyToManyAsync<TMany, TMany2>(this TMany many,
            Expression<Func<TMany, IEnumerable<TMany2>>> many2ListExpr, TMany2 many2,
            Expression<Func<TMany2, IEnumerable<TMany>>> manyListExpr)
            where TMany : <#=GlobalContainer.Settings.BaseEntityType#>
            where TMany2 : <#=GlobalContainer.Settings.BaseEntityType#>
        {
            if (many2 == null) return;
            if (!NHibernateUtil.IsInitialized(many2))
                await NHibernateUtil.InitializeAsync(many2).ConfigureAwait(false);
            var many2List = (ICollection<TMany2>)many2ListExpr.Compile()(many);
            var manyList = (ICollection<TMany>)manyListExpr.Compile()(many2);
            await RemoveIfExistAsync(manyList, many).ConfigureAwait(false);
            await RemoveIfExistAsync(many2List, many2).ConfigureAwait(false);
        }

        public static async Task SetOneToOneAsync<TOne, TOne2>(this TOne one,
            Expression<Func<TOne, TOne2>> one2Expr, TOne2 one2,
            Expression<Func<TOne2, TOne>> oneExpr)
            where TOne : <#=GlobalContainer.Settings.BaseEntityType#>
            where TOne2 : <#=GlobalContainer.Settings.BaseEntityType#>
        {
            if (one2 == null)
            {
                one.UnsetOneToOne(one2Expr, oneExpr);
                return;
            }
            if (!NHibernateUtil.IsInitialized(one2))
                await NHibernateUtil.InitializeAsync(one2).ConfigureAwait(false);

            var oneInOne2 = oneExpr.Compile()(one2);
            var oneInOne2PropInfo = GetPropertyInfo(one2, oneExpr);
            var currentOne2 = one2Expr.Compile()(one);
            var currentOne2PropInfo = GetPropertyInfo(one, one2Expr);

            if (oneInOne2 != null)
            {
                if (!NHibernateUtil.IsInitialized(oneInOne2))
                    await NHibernateUtil.InitializeAsync(oneInOne2).ConfigureAwait(false);
                await oneInOne2.UnsetOneToOneAsync(one2Expr, oneExpr).ConfigureAwait(false);
            }
            oneInOne2PropInfo.SetValue(one2, one);
            if (currentOne2 != null)
            {
                if (!NHibernateUtil.IsInitialized(currentOne2))
                    await NHibernateUtil.InitializeAsync(currentOne2).ConfigureAwait(false);
                await currentOne2.UnsetOneToOneAsync(oneExpr, one2Expr).ConfigureAwait(false);
            }
            currentOne2PropInfo.SetValue(one, one2);
        }

        public static async Task UnsetOneToOneAsync<TOne, TOne2>(this TOne one,
            Expression<Func<TOne, TOne2>> one2Expr,
            Expression<Func<TOne2, TOne>> oneExpr)
            where TOne : <#=GlobalContainer.Settings.BaseEntityType#>
            where TOne2 : <#=GlobalContainer.Settings.BaseEntityType#>
        {
            var one2 = one2Expr.Compile()(one);
            if (one2 == null) return;
            if (!NHibernateUtil.IsInitialized(one2))
                await NHibernateUtil.InitializeAsync(one2).ConfigureAwait(false);
            var one2PropInfo = GetPropertyInfo(one, one2Expr);
            var oneInOne2PropInfo = GetPropertyInfo(one2, oneExpr);

            oneInOne2PropInfo.SetValue(one2, null);
            one2PropInfo.SetValue(one, null);
        }
<#
    }
#>

        private static void RemoveIfExist<T>(ICollection<T> collection, T item)
        {
            if (collection.Contains(item))
                collection.Remove(item);
        }

        private static void AddIfNotExist<T>(ICollection<T> collection, T item)
        {
            if (!collection.Contains(item))
                collection.Add(item);
        }

        public static PropertyInfo GetPropertyInfo<TSource, TProperty>(TSource source, Expression<Func<TSource, TProperty>> propertyLambda)
        {
            var type = typeof(TSource);

            var member = propertyLambda.Body as MemberExpression;
            if (member == null)
                throw new ArgumentException(string.Format(
                    "Expression '{0}' refers to a method, not a property.",
                    propertyLambda));

            var propInfo = member.Member as PropertyInfo;
            if (propInfo == null)
                throw new ArgumentException(string.Format(
                    "Expression '{0}' refers to a field, not a property.",
                    propertyLambda.ToString()));

            if (type != propInfo.ReflectedType &&
                !type.IsSubclassOf(propInfo.ReflectedType))
                throw new ArgumentException(string.Format(
                    "Expresion '{0}' refers to a property that is not from type {1}.",
                    propertyLambda.ToString(),
                    type));

            return propInfo;
        }

        public static void AddOneToMany<TOne, TMany>(this TOne one,
            Expression<Func<TOne, IEnumerable<TMany>>> manyListExpr, TMany many,
            Expression<Func<TMany, TOne>> oneExpr,
            Expression<Func<TOne, Action<TMany>>> removeManyExpr)
            where TOne : <#=GlobalContainer.Settings.BaseEntityType#>
            where TMany : <#=GlobalContainer.Settings.BaseEntityType#>
        {
            if (many == null) return;
            var enumerable = manyListExpr.Compile()(one);
            var collection = (ICollection<TMany>)enumerable;
            var itemOwner = oneExpr.Compile()(many);
            var entityOwnerPropInfo = GetPropertyInfo(many, oneExpr);

            if (collection.Contains(many)) return;
            if (itemOwner != null)
                removeManyExpr.Compile()(itemOwner)(many);
            entityOwnerPropInfo.SetValue(many, one);
            collection.Add(many);

            /*
            if (location == null || Locations.Contains(location)) return;
            if (location.User != null)
                location.User.RemoveLocation(location);
            location.User = this;
            Locations.Add(location);
            */
        }

        public static void RemoveOneToMany<TOne, TMany>(this TOne one,
            Expression<Func<TOne, IEnumerable<TMany>>> manyListExpr, TMany many,
            Expression<Func<TMany, TOne>> entityExpr
            )
            where TOne : <#=GlobalContainer.Settings.BaseEntityType#>
            where TMany : <#=GlobalContainer.Settings.BaseEntityType#>
        {
            if (many == null) return;
            var enumerable = manyListExpr.Compile()(one);
            var collection = (ICollection<TMany>)enumerable;
            var entityOwnerPropInfo = GetPropertyInfo(many, entityExpr);

            if (!collection.Contains(many)) return;
            collection.Remove(many);
            entityOwnerPropInfo.SetValue(many, null);

            /*
            if (location == null || !Locations.Contains(location)) return;
            Locations.Remove(location);
            location.User = null;
            */
        }

        public static void SetManyToOne<TMany, TOne>(this TMany many,
            Expression<Func<TMany, TOne>> oneExpr, TOne newOne,
            Expression<Func<TOne, Action<TMany>>> removeManyExpr,
            Expression<Func<TOne, IEnumerable<TMany>>> manyExp)
            where TOne : <#=GlobalContainer.Settings.BaseEntityType#>
            where TMany : <#=GlobalContainer.Settings.BaseEntityType#>
        {
            if(newOne == null)
            {
                many.UnsetManyToOne(oneExpr, manyExp);
                return;
            }
            var one = oneExpr.Compile()(many);
            var onePropInfo = GetPropertyInfo(many, oneExpr);
            var manyList = (ICollection<TMany>)manyExp.Compile()(newOne);

            if (Equals(one, newOne)) return;
            if (one != null)
                removeManyExpr.Compile()(one)(many);
            onePropInfo.SetValue(many, newOne);
            AddIfNotExist(manyList, many);

            /*
            if (user == null)
            {
                UnsetUser();
            }
            if (User == user) return;
            if(User != null)
                User.RemoveLocation(this);
            User = user;
            AddIfNotExist(user.Locations, this);
            */
        }

        public static void UnsetManyToOne<TMany, TOne>(this TMany many,
            Expression<Func<TMany, TOne>> oneExpr,
            Expression<Func<TOne, IEnumerable<TMany>>> manyListExpr)
            where TOne : <#=GlobalContainer.Settings.BaseEntityType#>
            where TMany : <#=GlobalContainer.Settings.BaseEntityType#>
        {
            var one = oneExpr.Compile()(many);
            if (one == null) return;
            var onePropInfo = GetPropertyInfo(many, oneExpr);
            var manyList = (ICollection<TMany>)manyListExpr.Compile()(one);

            RemoveIfExist(manyList, many);
            onePropInfo.SetValue(many, null);
            /*
            if(User == null) return;
            RemoveIfExist(User.Locations, this);
            User = null;*/
        }

        public static void AddManyToMany<TMany, TMany2>(this TMany many,
            Expression<Func<TMany, IEnumerable<TMany2>>> many2ListExpr, TMany2 many2,
            Expression<Func<TMany2, IEnumerable<TMany>>> manyListExpr)
            where TMany : <#=GlobalContainer.Settings.BaseEntityType#>
            where TMany2 : <#=GlobalContainer.Settings.BaseEntityType#>
        {
            if (many2 == null) return;
            var many2List = (ICollection<TMany2>)many2ListExpr.Compile()(many);
            var manyList = (ICollection<TMany>)manyListExpr.Compile()(many2);

            AddIfNotExist(manyList, many);
            AddIfNotExist(many2List, many2);
            /*
            camera.Locations.AddIfNotExist(this);
            Cameras.AddIfNotExist(camera);*/
        }

        public static void RemoveManyToMany<TMany, TMany2>(this TMany many,
            Expression<Func<TMany, IEnumerable<TMany2>>> many2ListExpr, TMany2 many2,
            Expression<Func<TMany2, IEnumerable<TMany>>> manyListExpr)
            where TMany : <#=GlobalContainer.Settings.BaseEntityType#>
            where TMany2 : <#=GlobalContainer.Settings.BaseEntityType#>
        {
            if (many2 == null) return;
            var many2List = (ICollection<TMany2>)many2ListExpr.Compile()(many);
            var manyList = (ICollection<TMany>)manyListExpr.Compile()(many2);

            RemoveIfExist(manyList, many);
            RemoveIfExist(many2List, many2);
            /*
            RemoveIfExist(camera.Locations, this);
            RemoveIfExist(Cameras, camera);*/
        }

        public static void SetOneToOne<TOne, TOne2>(this TOne one,
            Expression<Func<TOne, TOne2>> one2Expr, TOne2 one2,
            Expression<Func<TOne2, TOne>> oneExpr)
            where TOne : <#=GlobalContainer.Settings.BaseEntityType#>
            where TOne2 : <#=GlobalContainer.Settings.BaseEntityType#>
        {
            if(one2 == null)
            {
                one.UnsetOneToOne(one2Expr, oneExpr);
                return;
            }
            var oneInOne2 = oneExpr.Compile()(one2);
            var oneInOne2PropInfo = GetPropertyInfo(one2, oneExpr);
            var currentOne2 = one2Expr.Compile()(one);
            var currentOne2PropInfo = GetPropertyInfo(one, one2Expr);

            if (oneInOne2 != null)
                oneInOne2.UnsetOneToOne(one2Expr, oneExpr);
            oneInOne2PropInfo.SetValue(one2, one);
            if (currentOne2 != null)
                currentOne2.UnsetOneToOne(oneExpr, one2Expr);
            currentOne2PropInfo.SetValue(one, one2);
            /*
            if(value == null)
            {
                MerryWith.UnSetMerryWith();
            }
             if(MerryWith.MerriedWith != null)
               MerryWith.UnSet
             MerryWith.MerriedWith = this;
             if(MerryWith != null)
               UnSetMerryWith
             MerriedWith = value;
             */
        }

        public static void UnsetOneToOne<TOne, TOne2>(this TOne one,
            Expression<Func<TOne, TOne2>> one2Expr,
            Expression<Func<TOne2, TOne>> oneExpr)
            where TOne : <#=GlobalContainer.Settings.BaseEntityType#>
            where TOne2 : <#=GlobalContainer.Settings.BaseEntityType#>
        {
            var one2 = one2Expr.Compile()(one);
            if (one2 == null) return;
            var one2PropInfo = GetPropertyInfo(one, one2Expr);
            var oneInOne2PropInfo = GetPropertyInfo(one2, oneExpr);

            oneInOne2PropInfo.SetValue(one2, null);
            one2PropInfo.SetValue(one, null);

            /*
            if (MerriedWith == null) return;
            MerriedWith.MerriedWith = null;  
            MerriedWith = null;
             */
        }

        private static object GetDefault(Type type)
        {
            if (type.IsValueType)
            {
                return Activator.CreateInstance(type);
            }
            return null;
        }
    }


    internal static class ExpressionExtensions
    {
        internal static string GetFullPropertyName<T, TProperty>(this Expression<Func<T, TProperty>> exp)
        {
            MemberExpression memberExp;
            if (!TryFindMemberExpression(exp.Body, out memberExp))
                return string.Empty;

            var memberNames = new Stack<string>();
            do
            {
                memberNames.Push(memberExp.Member.Name);
            }
            while (TryFindMemberExpression(memberExp.Expression, out memberExp));

            return string.Join(".", memberNames.ToArray());
        }

        private static bool TryFindMemberExpression(Expression exp, out MemberExpression memberExp)
        {
            memberExp = exp as MemberExpression;
            if (memberExp != null)
            {
                // heyo! that was easy enough
                return true;
            }

            // if the compiler created an automatic conversion,
            // it'll look something like...
            // obj => Convert(obj.Property) [e.g., int -> object]
            // OR:
            // obj => ConvertChecked(obj.Property) [e.g., int -> long]
            // ...which are the cases checked in IsConversion
            if (IsConversion(exp) && exp is UnaryExpression)
            {
                memberExp = ((UnaryExpression)exp).Operand as MemberExpression;
                if (memberExp != null)
                {
                    return true;
                }
            }

            return false;
        }

        private static bool IsConversion(Expression exp)
        {
            return (
                exp.NodeType == ExpressionType.Convert ||
                exp.NodeType == ExpressionType.ConvertChecked
            );
        }
    }


<#
    if(GlobalContainer.Settings.TypedMappingExtensions)
    {
#>
    public class Magic<TBase, TInherited> where TInherited : TBase
    {
        private Magic()
        {
        }
    }

    public static class T4FluentExtensions
    {
<#
        foreach (var entityType in GlobalContainer.Settings.EntityTypes)
        {
#>
        /// <summary>
        /// Specify the key column name using the given expression with additional "Id" postfix
        /// </summary>
        /// <typeparam name="TChild"></typeparam>
        /// <param name="oneToMany"></param>
        /// <param name="columnExp"></param>
        /// <returns></returns>
        public static OneToManyPart<TChild> KeyColumn<TChild>(this OneToManyPart<TChild> oneToMany, Expression<Func<TChild, object>> columnExp, Magic<<#=entityType.DerivedFromType#>, TChild> x = null)
            where TChild : <#=entityType.DerivedFromType#>
        {
            return oneToMany.KeyColumn("<#=entityType.KeyColumnPrefix#>" + columnExp.GetFullPropertyName() + "<#=entityType.KeyColumnPostfix#>");
        }
<#
        }
#>
    }
<#
    }
#>

}

<#+
public enum ModelRelationType
{
    None,
    OneToOne,
    OneToMany,
    ManyToOne,
    ManyToMany
}

public enum CollectionMapType
{
    Unknown = 0,
    Set,
    Bag,
    List
}

public enum AssociationType
{
    Unknown = 0,
    Unidirectional,
    Bidirectional
}

public abstract class ModelRelation
{
    #region Basic props

    public virtual ModelRelationType Type { get { return ModelRelationType.None; } }

    public string RelatedModelTypeFullName { get; set; }

    public string PathInRelatedModel { get; set; }

    public AssociationType AssociationType { get; set; }

    public string KeyColumn { get; set; }

    #endregion


    public DomainModelWrapper Model { get; set; }

    public DomainModelWrapper RelatedModel { get; set; }

    public EntityType RelatedModelEntityType { get; set; }

    public string FieldName { get; set; }

    public string ParameterName { get; set; }

    public string RelatedModelIdPropertyName
    {
        get { return RelatedModelEntityType.IdentifierPropertyName; }
    }

    public bool UseFullNamespaceForRelatedModelType
    {
        get
        {
            return !(
                RelatedModel != null &&
                (
                    Model.Namespace.FullName == RelatedModel.Namespace.FullName ||
                    GlobalContainer.KnownNamespaces.Contains(RelatedModel.Namespace.FullName)
                    )
                );
        }
    }

    public string RelatedModelTypeName //Is the same as RelatedModelTypeFullName when the related type is not is the same namespace
    {
        get
        {
            return RelatedModel != null
                ? (UseFullNamespaceForRelatedModelType ? RelatedModel.FullName : RelatedModel.Name)
                : (UseFullNamespaceForRelatedModelType ? RelatedModelTypeFullName : RelatedModelTypeFullName.Split('.').Last());
        }
    } 

    public CodeProperty Property { get; set; }

    public string PropertyName
    {
        get
        {
            return Property == null
                ? Model.Name
                : Property.Name;
        }
    }

    public string SingularPropertyName { get { return GlobalContainer.Singularize(PropertyName); } }

    
}

public class NoneModelRelation : ModelRelation
{
    public override ModelRelationType Type { get { return ModelRelationType.None; } }
}

public abstract class OneModelRelation : ModelRelation
{
    public bool GenerateSyntheticProperty { get; set; }

    public string SyntheticPropertyName { get; set; }

    public string SyntheticPropertyTypeName { get; set; }

    public string SyntheticFieldName { get; set; }

    public string SyntheticIsSetFieldName { get; set; }

    public string SyntheticPropertyMaxLength { get; set; }

    public bool IsSyntheticPropertyTypeRequired { get; set; }

    //Only set for bidirection relation
    public bool ExistsSetMethod { get; set; }

    public bool ExistsSetAsyncMethod { get; set; }

    public string SetMethodName { get; set; }

    public bool ExistsUnsetMethod { get; set; }

     public bool ExistsUnsetAsyncMethod { get; set; }

    public string UnsetMethodName { get; set; }
}

public class OneToOneModelRelation : OneModelRelation
{
    public override ModelRelationType Type { get { return ModelRelationType.OneToOne; } }
}

public class ManyToOneModelRelation : OneModelRelation
{
    public override ModelRelationType Type { get { return ModelRelationType.ManyToOne; } }

    public string RelatedTypeRemoveMethodName { get; set; }
}

public abstract class CollectionModelRelation : ModelRelation
{
    #region Basic props

    public string CollectionType { get; set; }

    public CollectionMapType CollectionMapType { get; set; }

    #endregion

    public string FieldCollectionType { get; set; }

    //Only set for bidirection relation

    public bool ExistsAddMethod { get; set; }

    public bool ExistsAddAsyncMethod { get; set; }

    public string AddMethodName { get; set; }

    public bool ExistsRemoveMethod { get; set; }

    public bool ExistsRemoveAsyncMethod { get; set; }

    public string RemoveMethodName { get; set; }
}

public class OneToManyModelRelation : CollectionModelRelation
{
    public override ModelRelationType Type { get { return ModelRelationType.OneToMany; } }
}

public class ManyToManyModelRelation : CollectionModelRelation
{
    public override ModelRelationType Type { get { return ModelRelationType.ManyToMany; } }
}

[Serializable]
public class EntityProjectItem
{
    [System.Xml.Serialization.XmlIgnoreAttribute]
    private readonly List<ProjectItem> _entityProjectItems = new List<ProjectItem>();
    [System.Xml.Serialization.XmlIgnoreAttribute]
    private readonly List<ProjectItem> _overrideProjectItems = new List<ProjectItem>();
    [System.Xml.Serialization.XmlIgnoreAttribute]
    private ProjectItem _generatedItem;

    public EntityProjectItem() {}

    public EntityProjectItem(string fullName)
    {
        EntityFullName = fullName;
        OverrideFilePaths = new List<string>();
        EntityFilePaths = new List<string>();
    }

    public string EntityFullName { get; set; }

    public List<string> EntityFilePaths { get; set; }

    public List<string> OverrideFilePaths { get; set; }

    public string GeneratedFilePath { get; set; }

    [System.Xml.Serialization.XmlIgnoreAttribute]
    public string GeneratedFileAbsoultePath { get { return _generatedItem.FileNames[0]; } }

    public void SetGeneratedFile(ProjectItem pItem)
    {
        _generatedItem = pItem;
        GeneratedFilePath = GlobalContainer.VSHelper.GetRelativePathToCurrentProject(pItem);
    }

    public void AddEntityFile(ProjectItem pItem)
    {
        _entityProjectItems.Add(pItem);
        EntityFilePaths.Add(GlobalContainer.VSHelper.GetRelativePathToCurrentProject(pItem));
    }

    public void AddOverrideFile(ProjectItem pItem)
    {
        _overrideProjectItems.Add(pItem);
        OverrideFilePaths.Add(GlobalContainer.VSHelper.GetRelativePathToCurrentProject(pItem));
    }

    public bool IsDirty()
    {
        if (string.IsNullOrEmpty(GeneratedFilePath)) return true;

        //Get EntityProjectItem instance from the generated file
        var path = GetFullPathByRelative(GeneratedFilePath);
        if (!File.Exists(path))
            return true;
        var genFileText = File.ReadAllText(path);
        var match = Regex.Match(genFileText, "//(<EntityProjectItem.*</EntityProjectItem>)");
        if (!match.Success) return true;
        var xml = match.Groups[1].Value;
        var serializer = new System.Xml.Serialization.XmlSerializer(typeof(EntityProjectItem));
        EntityProjectItem result;

        using (var reader = new StringReader(xml))
        {
            result = (EntityProjectItem)serializer.Deserialize(reader);
        }

        //Check if any of the files was renamed or deleted
        if (!AreEqual(result)) return true;

        //Check if there is any override or entity class that has greater LastWriteTime than the generated file
        var genWriteTime = File.GetLastWriteTime(GetFullPathByRelative(GeneratedFilePath));
        return _entityProjectItems.Union(_overrideProjectItems)
            .Any(pItem =>
            {
                var absPath = pItem.FileNames[0];
                if (File.GetLastWriteTime(absPath) > genWriteTime) return true; //was modified
                if (!pItem.Saved) return true; //was modified but not yet saved
                return false;
            });
    }

    private string GetFullPathByRelative(string relative)
    {
        return Path.Combine(Path.GetDirectoryName(GlobalContainer.VSHelper.CurrentProject.FullName), relative);
    }

    public bool AreEqual(EntityProjectItem item)
    {
        return (
            item.GeneratedFilePath == GeneratedFilePath &&
            item.EntityFullName == EntityFullName &&

            item.EntityFilePaths.Count == EntityFilePaths.Count &&
            item.EntityFilePaths.All(o => EntityFilePaths.Contains(o)) &&
            EntityFilePaths.All(o => item.EntityFilePaths.Contains(o)) &&

            item.OverrideFilePaths.Count == OverrideFilePaths.Count &&
            item.OverrideFilePaths.All(o => OverrideFilePaths.Contains(o)) &&
            OverrideFilePaths.All(o => item.OverrideFilePaths.Contains(o))
        );
    }

    public string Serialize()
    {
        var xmlSerializer = new System.Xml.Serialization.XmlSerializer(typeof(EntityProjectItem));
        var settings = new System.Xml.XmlWriterSettings
        {
            OmitXmlDeclaration = true,
            Indent = false
        };
        using(var strWriter = new StringWriter())
        using(var writer = System.Xml.XmlWriter.Create(strWriter, settings))
        {
            xmlSerializer.Serialize(writer, this);
            return strWriter.ToString();
        }
    }
}

public static class GlobalContainer
{
    public static CSharpCodeProvider CSharpCodeProvider = new CSharpCodeProvider();

    public static VisualStudioHelper VSHelper;

    public static XmlSettings Settings;

    public static Dictionary<string, List<ModelRelation>> GlobalModelRelations;

    public static Dictionary<string, DomainModelWrapper> DomainClasses;

    public static HashSet<string> KnownNamespaces;

    public static Dictionary<string, EntityOverride> Overrides; //Dict<typeFullName, Dict<propName, Relation>>

    public static Dictionary<string, List<CodeClass2>> ProjectTypes;

    public static IEnumerable<ProjectItem> ProjectItems;

    public static HashSet<ProjectItem> DomainProjectItems;

    public static Dictionary<string, EntityProjectItem> EntityProjectItems;

    public static Dictionary<string, Dictionary<string, CodeProperty>> Components; //Dict<typeFullName, PropName, PropTypefullName>


    public static string Singularize(string name)
    {
        foreach (var singularize in Settings.Singularization
            .Where(singularize => Regex.IsMatch(name, singularize.Pattern)))
        {
            return Regex.Replace(name, singularize.Pattern, singularize.Replace);
        }

        return VSHelper.Singularize(name);
    }

    public static void Reset()
    {
        GlobalModelRelations.Clear();
        DomainClasses.Clear();
        Overrides.Clear();
        EntityProjectItems.Clear();
        Components.Clear();
        DomainProjectItems.Clear();
    }

    public static EntityType GetEntityType(CodeClass2 codeClass, bool throwIfNotFound)
    {
        return Settings.GetEntityType(VSHelper, codeClass, throwIfNotFound);
    }

    public static void AddGlobalModelRelation(string typeFullName, ModelRelation relation)
    {
        if(!GlobalModelRelations.ContainsKey(typeFullName))
            GlobalModelRelations.Add(typeFullName, new List<ModelRelation>());
        GlobalModelRelations[typeFullName].Add(relation);
    }

    static GlobalContainer()
    {
        GlobalModelRelations = new Dictionary<string, List<ModelRelation>>();
        DomainClasses = new Dictionary<string, DomainModelWrapper>();
        Overrides = new Dictionary<string, EntityOverride>();
        ProjectTypes = new Dictionary<string, List<CodeClass2>>();
        Components = new Dictionary<string, Dictionary<string, CodeProperty>>();
        EntityProjectItems = new Dictionary<string, EntityProjectItem>();
        DomainProjectItems = new HashSet<ProjectItem>();
    }
}


public class DomainModelWrapper
{
    public DomainModelWrapper()
    {
        MappedProperties = new Dictionary<string, CodeProperty>();
        RelatedModels = new List<ModelRelation>();
    }
    
    #region Settable props

    public string SettingsXml { get; set; }

    public CodeClass2 CodeClass { get; set; }

    public ProjectItem ProjectItem { get; set; }

    public bool WasModified { get; set; }

    public List<ModelRelation> RelatedModels { get; set; }

    #endregion


    public Dictionary<string, CodeProperty> MappedProperties { get; private set; }

    public EntityType EntityType { get; private set; }

    public string FullClassName
    {
        get
        {
            return CodeClass.IsGeneric
                ? Name + string.Format("<{0}>", string.Join(", ", GlobalContainer.VSHelper.GetGenericAgruments(FullName)))
                : Name;
        }
    }

    public string FileName
    {
        get
        {
            return CodeClass.IsGeneric
                ? string.Format("{0}({1})", Name, string.Join("_", GlobalContainer.VSHelper.GetGenericAgruments(FullName)))
                : Name;
        }
    }

    public string Name { get { return CodeClass.Name; } }

    public CodeNamespace Namespace { get { return CodeClass.Namespace; } }

    public string FullName { get { return CodeClass.FullName; } }

    public void Merge(DomainModelWrapper wrapper)
    {
        if(FullName != wrapper.FullName)
            throw new Exception("Cannot merge two ModelWrappers with different types");
        foreach(var pair in wrapper.MappedProperties)
        {
            if(MappedProperties.ContainsKey(pair.Key))
            {
                GlobalContainer.VSHelper.Warning(string.Format("Cannot add an existing property! Entity {0}, duplicate property {1}", FullName, pair.Key));
                continue;
            }
            MappedProperties.Add(pair.Key, pair.Value);
        }
        foreach(var relation in wrapper.RelatedModels)
        {
            if(RelatedModels.Contains(relation)) //TODO: fix this
            {
                GlobalContainer.VSHelper.Warning(string.Format("Cannot add an existing relation! Entity {0}, duplicate relation {1}", FullName, relation.RelatedModelTypeName));
                continue;
            }
            RelatedModels.Add(relation);
        }
    }


    public void Initialize()
    {
        GlobalContainer.VSHelper.SetAsPartial(CodeClass);
        EntityType = GlobalContainer.GetEntityType(CodeClass, true);

        //Setup global relations
        if (GlobalContainer.GlobalModelRelations.ContainsKey(FullName))
        {
            foreach (var globalRelation in GlobalContainer.GlobalModelRelations[FullName])
            {
                SetupRelation(globalRelation);
                RelatedModels.Add(globalRelation);
            }
        }

        //Editing properties 
        //VSHelper.Warning(CodeClass.FullName + " "+  VSHelper.GetProperties(CodeClass).Count().ToString());
        //VSHelper.Warning(CodeClass.FullName);
        foreach(var prop in GlobalContainer.VSHelper.GetProperties(CodeClass))
        {
            var prop2 = prop as CodeProperty2;
            //dont touch overrides and abstract props           
            if(prop2 != null && prop2.OverrideKind != vsCMOverrideKind.vsCMOverrideKindOverride && prop2.OverrideKind != vsCMOverrideKind.vsCMOverrideKindAbstract)
                GlobalContainer.VSHelper.SetAsVirtual(prop2);

            if (!GlobalContainer.VSHelper.IsNHibernateProperty(prop) || GlobalContainer.Settings.IgnoreTypes.Contains(prop.Type.AsFullName) ||
                prop.Type.TypeKind == vsCMTypeRef.vsCMTypeRefOther) //Generic type
                continue;
            
            if (GlobalContainer.VSHelper.IsEnumerable(prop.Type) && GlobalContainer.VSHelper.IsGeneric(prop.Type))
            {
                var itemType = GlobalContainer.VSHelper.GetGenericAgruments(prop.Type).First();
                if (GlobalContainer.Settings.IgnoreTypes.Contains(itemType)) continue;
            }

            MappedProperties.Add(prop.Name, prop);
            
            EditMappedProperty(prop);
                
        }

        if (GlobalContainer.Settings.SyntheticProperties.GenerateForDeriveredTypes)
        {
            //Generate synthetic props for inherited props if not present in the base class
            foreach (var prop in GlobalContainer.VSHelper.GetInheritedProperties(CodeClass))
            {
                var relation = GetRelation(prop);
                if(relation.Type == ModelRelationType.None)
                    continue;
                SetupRelation(relation);
                var oneRelation = relation as OneModelRelation;
                if(oneRelation != null && oneRelation.GenerateSyntheticProperty)
                    RelatedModels.Add(relation);
            }
        }

        //Define methods as virtual
        foreach(var method in GlobalContainer.VSHelper.GetMethods(CodeClass)
                .Where(o => o.Access != vsCMAccess.vsCMAccessPrivate)
                .Where(o => o.OverrideKind != vsCMOverrideKind.vsCMOverrideKindAbstract)
                .Where(o => o.OverrideKind != vsCMOverrideKind.vsCMOverrideKindOverride))
        {
            if(method.Access != vsCMAccess.vsCMAccessPrivate)
                method.OverrideKind = vsCMOverrideKind.vsCMOverrideKindVirtual;
        }

        if (GlobalContainer.VSHelper.VisualStudioVersion >= 14 && !ProjectItem.IsOpen) //VS 2015 crash if the item is not open
            ProjectItem.Open();

        ProjectItem.Save(); //Save the item
    }

    private void SetupRelation(ModelRelation relation)
    {
        relation.Model = this;
        if (relation.Type == ModelRelationType.None) return;

        var relatedType = GlobalContainer.DomainClasses.ContainsKey(relation.RelatedModelTypeFullName)
            ? GlobalContainer.DomainClasses[relation.RelatedModelTypeFullName]
            : null; //external type
        relation.RelatedModel = relatedType;
        relation.RelatedModelEntityType = relatedType != null
                        ? GlobalContainer.GetEntityType(relatedType.CodeClass, true)
                        : GlobalContainer.Settings.GetExternalEntityType(relation.RelatedModelTypeFullName, true);
        relation.FieldName = GlobalContainer.VSHelper.GetFieldName(relation.PropertyName);
        relation.ParameterName = GlobalContainer.Singularize(GlobalContainer.VSHelper.FirstCharToLower(relation.PropertyName));
        if (!GlobalContainer.CSharpCodeProvider.IsValidIdentifier(relation.ParameterName))
            relation.ParameterName = "@" + relation.ParameterName;

        switch (relation.Type)
        {
            case ModelRelationType.OneToMany:
            case ModelRelationType.ManyToMany:
                var collectionRelation = (CollectionModelRelation) relation;
                collectionRelation.FieldCollectionType = GlobalContainer.VSHelper.GetValidNHibernteEnumerableInterface(relation.Property,
                    collectionRelation.CollectionType, GlobalContainer.Settings.Strict, relation.RelatedModelTypeName);
                if (relation.AssociationType == AssociationType.Bidirectional)
                {
                    collectionRelation.AddMethodName = "Add" + collectionRelation.SingularPropertyName;
                    collectionRelation.ExistsAddMethod = GlobalContainer.VSHelper.GetMethods(CodeClass, true)
                        .Any(o => o.Name == collectionRelation.AddMethodName && 
                            o.Parameters.Count == 1 &&
                            o.Parameters.OfType<CodeParameter>().First().Type.AsFullName == relation.RelatedModelTypeFullName);

                    collectionRelation.ExistsAddAsyncMethod = GlobalContainer.VSHelper.GetMethods(CodeClass, true)
                        .Any(o => o.Name == collectionRelation.AddMethodName + "Async" && 
                            o.Parameters.Count == 1 &&
                            o.Parameters.OfType<CodeParameter>().First().Type.AsFullName == relation.RelatedModelTypeFullName);

                    collectionRelation.RemoveMethodName = "Remove" + collectionRelation.SingularPropertyName;
                    collectionRelation.ExistsRemoveMethod = GlobalContainer.VSHelper.GetMethods(CodeClass, true)
                        .Any(o => o.Name == collectionRelation.RemoveMethodName && 
                            o.Parameters.Count == 1 &&
                            o.Parameters.OfType<CodeParameter>().First().Type.AsFullName == relation.RelatedModelTypeFullName);

                    collectionRelation.ExistsRemoveAsyncMethod = GlobalContainer.VSHelper.GetMethods(CodeClass, true)
                        .Any(o => o.Name == collectionRelation.RemoveMethodName + "Async" && 
                            o.Parameters.Count == 1 &&
                            o.Parameters.OfType<CodeParameter>().First().Type.AsFullName == relation.RelatedModelTypeFullName);
                }
                break;

            case ModelRelationType.ManyToOne:
            case ModelRelationType.OneToOne:
                var oneRelation = (OneModelRelation) relation;
                oneRelation.SetMethodName = "Set" + relation.PropertyName;
                oneRelation.ExistsSetMethod = GlobalContainer.VSHelper.GetMethods(CodeClass, true)
                        .Any(o => o.Name == oneRelation.SetMethodName && 
                            o.Parameters.Count == 1 &&
                            o.Parameters.OfType<CodeParameter>().First().Type.AsFullName == relation.RelatedModelTypeFullName);

                oneRelation.ExistsSetAsyncMethod = GlobalContainer.VSHelper.GetMethods(CodeClass, true)
                        .Any(o => o.Name == oneRelation.SetMethodName + "Async" && 
                            o.Parameters.Count == 1 &&
                            o.Parameters.OfType<CodeParameter>().First().Type.AsFullName == relation.RelatedModelTypeFullName);

                oneRelation.UnsetMethodName = "Unset" + relation.PropertyName;
                oneRelation.ExistsUnsetMethod = GlobalContainer.VSHelper.GetMethods(CodeClass, true)
                        .Any(o => o.Name == oneRelation.UnsetMethodName && o.Parameters.Count == 0);

                oneRelation.ExistsUnsetAsyncMethod = GlobalContainer.VSHelper.GetMethods(CodeClass, true)
                        .Any(o => o.Name == oneRelation.UnsetMethodName + "Async" && o.Parameters.Count == 0);

                if (relation.Type == ModelRelationType.ManyToOne)
                {
                    var manyToOne = (ManyToOneModelRelation) relation;
                    if(!string.IsNullOrEmpty(relation.PathInRelatedModel))
                        manyToOne.RelatedTypeRemoveMethodName = "Remove" + GlobalContainer.Singularize(relation.PathInRelatedModel);
                }
    
                if(GlobalContainer.Settings.SyntheticProperties.Generate)
                {
                    
                    var syntheticPropValueType = GlobalContainer.VSHelper.IsValueType(relation.RelatedModelEntityType.IdentifierPropertyType);
                    oneRelation.SyntheticPropertyTypeName = GlobalContainer.VSHelper.SimplifyTypeName(relation.RelatedModelEntityType.IdentifierPropertyType);
                    oneRelation.IsSyntheticPropertyTypeRequired =
                        relation.Property != null &&
                        GlobalContainer.VSHelper.GetAttribute(relation.Property.Attributes, GlobalContainer.Settings.NotNullAttribute) != null;
                    if (!oneRelation.IsSyntheticPropertyTypeRequired && syntheticPropValueType)
                        oneRelation.SyntheticPropertyTypeName += "?";
                    oneRelation.SyntheticPropertyName = !string.IsNullOrEmpty(relation.KeyColumn)
                        ? relation.KeyColumn
                        : relation.RelatedModelEntityType.KeyColumnPrefix + relation.PropertyName + relation.RelatedModelEntityType.KeyColumnPostfix;
                    oneRelation.SyntheticFieldName = GlobalContainer.VSHelper.GetFieldName(oneRelation.SyntheticPropertyName);
                    oneRelation.SyntheticIsSetFieldName = "_is" + oneRelation.SyntheticPropertyName + "Set";
                    oneRelation.SyntheticPropertyMaxLength = relation.RelatedModelEntityType.GetIdentifierLength(relation.RelatedModelTypeFullName);
                    oneRelation.GenerateSyntheticProperty = 
                        GlobalContainer.VSHelper.GetProperties(CodeClass, true)
                            .All(o => o.Name != oneRelation.SyntheticPropertyName); //Check if is already defined
                }
                break;
        }
    }

    private ModelRelation GetRelation(CodeProperty prop)
    {
        if (GlobalContainer.Overrides.ContainsKey(FullName) && GlobalContainer.Overrides[FullName].Relations.ContainsKey(prop.Name))
            return GlobalContainer.Overrides[FullName].Relations[prop.Name];

        var one = !(GlobalContainer.VSHelper.IsEnumerable(prop.Type) && GlobalContainer.VSHelper.IsGeneric(prop.Type));
        var typeFullName = one
            ? prop.Type.CodeType.FullName
            : GlobalContainer.VSHelper.GetGenericAgruments(prop.Type).First();

        if(typeFullName.StartsWith("System."))
            return new NoneModelRelation();

        var externalType = /*!GlobalContainer.ProjectTypes.ContainsKey(typeFullName);*/GlobalContainer.Settings.IsExternalType(typeFullName); //ContainsKey does not work for generics

        //External type cannot have a bidirectional association
        if (!externalType)
        {
            if(!GlobalContainer.ProjectTypes.ContainsKey(typeFullName))
            {
                if(!typeFullName.StartsWith("System."))
                    GlobalContainer.VSHelper.Warning(String.Format("Type {0} does not exists in the current project, skiping relation for property '{1}' in '{2}'", 
                    typeFullName, prop.Name, FullClassName));
                return new NoneModelRelation();
            }
            //Skip further processing if the related type is not an entity
            if (!GlobalContainer.ProjectTypes[typeFullName].Any(o =>  GlobalContainer.VSHelper.IsDerivedFrom(o, GlobalContainer.Settings.BaseEntityType)))
            {
                return new NoneModelRelation();
            }

            //Check for Bidirectional association
            foreach(var cls in GlobalContainer.ProjectTypes[typeFullName])
            {
                foreach(var p in GlobalContainer.VSHelper.GetProperties(cls, true))
                {
                    if(GlobalContainer.VSHelper.IsEnumerable(p.Type) && 
                        GlobalContainer.VSHelper.IsGeneric(p.Type) && 
                        GlobalContainer.VSHelper.GetGenericAgruments(p.Type).First() == FullName && 
                        prop.Name == cls.Name) //generic collection
                    {
                        //VSHelper.Warning(cls.Name +  " " + p.Name  + " " + typeFullName + " " + (one ?  "OM" : "MM"));
                        if (one)
                        {
                            return new ManyToOneModelRelation
                            {
                                RelatedModelTypeFullName = typeFullName,
                                Property = prop,
                                PathInRelatedModel = p.Name,
                                AssociationType = AssociationType.Bidirectional
                            };
                        }
                        return new ManyToManyModelRelation
                        {
                            RelatedModelTypeFullName = typeFullName,
                            CollectionType = GlobalContainer.VSHelper.GetPropertyType(prop),
                            Property = prop,
                            PathInRelatedModel = p.Name,
                            AssociationType = AssociationType.Bidirectional
                        };
                    }
                    if (p.Type.AsFullName != FullName) continue;
                    if (one && 
                        (
                            //by default convention one to one is not generated
                            GlobalContainer.VSHelper.GetAttribute(prop.Attributes, "T4FluentNH.Attributes.AsOneToOneAttribute") == null ||
                            //property must be the same when one to one is defined on the same type
                            (typeFullName == FullName && p.Name != prop.Name)
                        )
                    )
                    {
                        continue;
                    }

                    if (one)
                    {
                        return new OneToOneModelRelation
                        {
                            RelatedModelTypeFullName = typeFullName,
                            Property = prop,
                            PathInRelatedModel = p.Name,
                            AssociationType = AssociationType.Bidirectional
                        };
                    }

                    //VSHelper.Warning(cls.Name +  " " + p.Name  + " " + typeFullName + " " + (one ?  "OO" : "MO"));
                    return new OneToManyModelRelation
                    {
                        RelatedModelTypeFullName = typeFullName,
                        CollectionType = GlobalContainer.VSHelper.GetPropertyType(prop),
                        Property = prop,
                        PathInRelatedModel = p.Name,
                        AssociationType = AssociationType.Bidirectional
                    };
                }
            }
        }


        //Unidirectional association - By default unidirectional associations are oneToMany and manyToOne
        //VSHelper.Warning(typeFullName +  " " + prop.Name  + " " + (one ?  "MO" : "MM"));
        //manyToOne
        if (one)
        {
            return new ManyToOneModelRelation
            {
                RelatedModelTypeFullName = typeFullName,
                Property = prop,
                PathInRelatedModel = null,
                AssociationType = AssociationType.Unidirectional
            };
        }

        //oneToMany - in this case we have to add two relations for both sides
        /*
        AddGlobalModelRelation(typeFullName, new ModelRelation
        {
            Type = ModelRelationType.ManyToOne,
            RelatedModelType = FullName,
            ListType = null,
            Property = null,
            PathInRelatedModel = prop.Name,
            AssociationType = AssociationType.Unidirectional
        });*/

        return new OneToManyModelRelation
        {
            RelatedModelTypeFullName = typeFullName,
            CollectionType = GlobalContainer.VSHelper.GetPropertyType(prop),
            Property = prop,
            PathInRelatedModel = null,
            AssociationType = AssociationType.Unidirectional
        };
    }

    private void EditMappedManyRelation(CodeProperty prop, CollectionModelRelation relation)
    {
        //Gtt.Warning(string.Format("{0} - {1} = {2}", FullName, listType, relation));
        GlobalContainer.VSHelper.SetAsPublic(prop);
        var listImplType = GlobalContainer.VSHelper.GetEnumerableImplType(prop);
        if (listImplType == null)
        {
            var colMapType = relation.CollectionMapType;
            if (colMapType == CollectionMapType.Unknown)
            {
                GlobalContainer.VSHelper.Warning(string.Format("CollectionMapType is not set for property '{0}' in class '{1}'",
                    prop.Name, Name));
                colMapType = GlobalContainer.Settings.DefaultCollectionMapType;
            }
            switch (colMapType)
            {
                case CollectionMapType.Set:
                case CollectionMapType.Bag:
                    listImplType = "HashSet";
                    break;
                case CollectionMapType.List:
                    listImplType = "List";
                    break;
            }
        }

        var newType = GlobalContainer.VSHelper.GetValidNHibernteEnumerableInterface(prop, listImplType, GlobalContainer.Settings.Strict);
        GlobalContainer.VSHelper.SetPropertyType(prop, newType);
        var body = string.Format(@"
        {{
            {0}
            {1}
        }}",
        string.Format("get {{ return {0} ?? ({0} = new {1}<{2}>()); }}", GlobalContainer.VSHelper.GetFieldName(prop.Name),
                listImplType, GlobalContainer.VSHelper.GetClassName(relation.RelatedModelTypeFullName)),
        string.Format("{0}set {{ {1} = value; }}", GlobalContainer.Settings.Strict ? "protected " : "",
                GlobalContainer.VSHelper.GetFieldName(prop.Name)));
        GlobalContainer.VSHelper.SetPropertyBody(prop, body);    
    }

    private void EditMappedOneRelation(CodeProperty prop, OneModelRelation relation)
    {
        if (relation.GenerateSyntheticProperty)
        {
        var body = string.Format(@"
        {{
            {0}
            {1}
        }}",
            string.Format("get {{ return {0}; }}", relation.FieldName),
            string.Format("{2}set {{ ResetField(ref {0}, value, ref {1}); }}", 
                relation.FieldName,
                //relation.SyntheticFieldName,
                relation.SyntheticIsSetFieldName,
                (GlobalContainer.Settings.Strict ? "protected internal " : "")));
            GlobalContainer.VSHelper.SetPropertyBody(prop, body);    
        }
        else
        {
            GlobalContainer.VSHelper.SetSetter(prop, GlobalContainer.Settings.Strict ? "protected internal set;" : "set;");
        }
    }

    private void EditMappedComponent(CodeProperty prop)
    {
        var body = string.Format(@"
        {{
            {0}
            {1}
        }}", string.Format("get {{ return {0} ?? ({0} = new {1}()); }}", GlobalContainer.VSHelper.GetFieldName(prop.Name), prop.Type.CodeType.Name),
            string.Format("{0}set {{ {1} = value; }}", GlobalContainer.Settings.Strict ? "protected " : "", GlobalContainer.VSHelper.GetFieldName(prop.Name)));
        GlobalContainer.VSHelper.SetPropertyBody(prop, body);
    }

    private void EditMappedProperty(CodeProperty prop)
    {
        var relation = GetRelation(prop);
        SetupRelation(relation);
        if (relation.Type != ModelRelationType.None)
        {
            var colleactionRelaton = relation as CollectionModelRelation;
            if(colleactionRelaton != null)
                EditMappedManyRelation(prop, colleactionRelaton);
            
            var oneRelation = relation as OneModelRelation;
            if(oneRelation != null)
                EditMappedOneRelation(prop, oneRelation);

            RelatedModels.Add(relation);
        }

        //Component
        if (GlobalContainer.Components.ContainsKey(FullName) && GlobalContainer.Components[FullName].ContainsKey(prop.Name))
        {
            EditMappedComponent(prop);
        }
    }
}

#>
<#+

    public class EntityOverride
    {
        public EntityOverride()
        {
            Relations = new Dictionary<string, ModelRelation>();
        }

        public CodeClass2 Class { get; set; }

        public string OverrideType { get; set; }

        public Dictionary<string, ModelRelation> Relations { get; set; }
        
        public CodeFunction2 OverrideMethod { get; set; }
    }

    public class EntityType
    {
        public string DerivedFromType { get; set; }

        public string KeyColumnPrefix { get; set; }

        public string KeyColumnPostfix { get; set; }

        public string IdentifierPropertyType { get; set; }

        public string IdentifierPropertyName { get; set; }

        public string IdentifierLength { get; set; }

        public List<AttributeIdentifierLength> AttributeIdentifierLengths { get; set; }

        public Dictionary<string,string> CustomIdentifierLengths { get; set; }

        public string GetIdentifierLength(string typeFullName)
        {
            if (CustomIdentifierLengths.ContainsKey(typeFullName))
                return CustomIdentifierLengths[typeFullName];

            //Check for attribute
            if(AttributeIdentifierLengths.Any() && GlobalContainer.ProjectTypes.ContainsKey(typeFullName))
            {
                CodeAttribute2 attr = null;
                foreach(var cls in GlobalContainer.ProjectTypes[typeFullName])
                {
                    foreach(var attrLength in AttributeIdentifierLengths)
                    {
                        attr = GlobalContainer.VSHelper.GetAttribute(cls.Attributes, attrLength.Type);
                        if(attr != null)
                        {
                            if(attrLength.ParameterIndex.HasValue) //example: attr.Value = ""asdas",    11"
                            {
                                var values = attr.Value.Trim().Split(',')
                                    .Where(o => o != null)
                                    .Select(o => o.Trim())
                                    .ToList();
                                if(attrLength.ParameterIndex.Value < values.Count)
                                    return values[attrLength.ParameterIndex.Value];
                            }
                            else if(!string.IsNullOrEmpty(attrLength.PropertyName)) //example: attr.Value = "Test="asdas",   Length =   11"
                            {
                                var prop = attr.Value.Trim().Split(',')
                                    .Where(o => o != null && o.Split('=').Length == 2)
                                    .Select(o => new { 
                                        Property = o.Trim().Split('=')[0].Trim(), 
                                        Value = o.Trim().Split('=')[1].Trim() 
                                    })
                                    .FirstOrDefault(o => o.Property == attrLength.PropertyName);
                                if(prop != null)
                                    return prop.Value; 
                            }

                            break;
                        }
                    }
                }
            }

            return IdentifierLength;
        }
    }

    public class AttributeIdentifierLength
    {
        public string Type { get; set; }

        public string PropertyName { get; set; }

        public int? ParameterIndex { get; set; }
    }
    /*
    public class ExternalType
    {
        public string FullName { get; set; }

        public string DerivedFromType { get; set; }

    }
    */
    public class Singularize
    {
        public string Pattern { get; set; }

        public string Replace { get; set; }

    }

    public class SyntheticProperties
    {
        public bool Generate { get; set; }

        public string Comment { get; set; }

        public bool AddNotNullAttribute { get; set; }

        public bool AddLengthAttribute { get; set; }

        public List<string> CustomAttributes { get; set; }

        public bool GenerateForDeriveredTypes { get; set; }
    }

    public class GenerateMetadata
    {
        public bool Relations { get; set; }
    }

    public class XmlSettings
    {
        private static bool GetBoolean(XElement xml, string path, bool defVal = false)
        {
            var elem = xml.XPathSelectElement(path);
            return elem == null ? defVal : elem.Value.ToUpperInvariant() == "TRUE";
        }

        private static string GetString(XElement xml, string path, string defVal = null)
        {
            var elem = xml.XPathSelectElement(path);
            return elem == null ? defVal : elem.Value;
        }

        private static T GetEnum<T>(XElement xml, string path, T defVal = default(T))
        {
            var elem = xml.XPathSelectElement(path);
            return elem == null ? defVal : (T) Enum.Parse(typeof (T), elem.Value, true);
        }

        private static List<string> GetStringList(XElement xml, string path)
        {
            return xml.XPathSelectElements(path).Select(o => o.Value).ToList();
        }

        private static int? GetNullableInt(XElement xml, string path, int? defVal = null)
        {
            var elem = xml.XPathSelectElement(path);
            if (elem == null)
                return defVal;
            int num;
            return int.TryParse(elem.Value, out num) ? num : defVal;
        }

        public static XmlSettings Load(string path)
        {
            if(!File.Exists(path))
                throw new FileNotFoundException(string.Format("Missing settings at: '{0}'", path));

            var xElement = XElement.Load(path);
            
            var settings = new XmlSettings
            {
                BaseEntityType = GetString(xElement, "/BaseEntityType"),
                Strict = GetBoolean(xElement, "/Strict"),
                DefaultCollectionMapType = GetEnum<CollectionMapType>(xElement, "/DefaultCollectionMapType"),
                SyntheticProperties = new SyntheticProperties
                {
                    AddLengthAttribute = GetBoolean(xElement, "/SyntheticProperties/AddLengthAttribute"),
                    AddNotNullAttribute = GetBoolean(xElement, "/SyntheticProperties/AddNotNullAttribute"),
                    Comment = GetString(xElement, "/SyntheticProperties/Comment"),
                    Generate = GetBoolean(xElement, "/SyntheticProperties/Generate"),
                    CustomAttributes = GetStringList(xElement, "SyntheticProperties/CustomAttributes//CustomAttribute"),
                    GenerateForDeriveredTypes = GetBoolean(xElement, "/SyntheticProperties/GenerateForDeriveredTypes")
                },
                EntityTypes = xElement.XPathSelectElements("/EntityTypes//EntityType")
                    .Select(o => new EntityType
                    {
                        DerivedFromType = GetString(o, "DerivedFromType"),
                        KeyColumnPrefix = GetString(o, "KeyColumn/Prefix", string.Empty),
                        KeyColumnPostfix = GetString(o, "KeyColumn/Postfix", string.Empty),
                        IdentifierPropertyType = GetString(o, "IdentifierPropertyType"),
                        IdentifierPropertyName = GetString(o, "IdentifierPropertyName"),
                        IdentifierLength = GetString(o, "IdentifierLength"),
                        AttributeIdentifierLengths = o.XPathSelectElements("AttributeIdentifierLengths//AttributeIdentifierLength")
                            .Select(attr => new AttributeIdentifierLength
                                {
                                    Type = GetString(attr, "Type"),
                                    PropertyName = GetString(attr, "PropertyName"),
                                    ParameterIndex = GetNullableInt(attr, "ParameterIndex"),
                                })
                            .ToList(),
                        CustomIdentifierLengths = o.XPathSelectElements("CustomIdentifierLengths//CustomIdentifierLength")
                            .ToDictionary(c => GetString(c, "Type"), c => GetString(c, "Length"))
                    })
                    .ToList(),
                Singularization = xElement.XPathSelectElements("/Singularization//Singularize")
                    .Select(o => new Singularize
                    {
                        Pattern = GetString(o, "Pattern"),
                        Replace = GetString(o, "Replace"),
                    })
                    .ToList(),
                GenerateMetadata = new GenerateMetadata
                {
                    Relations  = GetBoolean(xElement, "/GenerateMetadata/Relations")
                },
                IgnoreTypes = new HashSet<string>(xElement.XPathSelectElements("/IgnoreTypes//IgnoreType").Select(o => o.Value)),
                NotNullAttribute = GetString(xElement, "/NotNullAttribute"),
                LengthAttribute = GetString(xElement, "/LengthAttribute"),
                AsyncMethods = GetBoolean(xElement, "/AsyncMethods"),
                TypedMappingExtensions = GetBoolean(xElement, "/TypedMappingExtensions"),
                ReadOnlyAttributeConvention = GetBoolean(xElement, "/ReadOnlyAttributeConvention"),
                ExternalAssemblies = xElement.XPathSelectElements("/ExternalAssemblies//ExternalAssemblyPath")
                    .Select(o =>
                    {
                        byte[] data;
                        var assemblyPath = GlobalContainer.VSHelper.GetFullPathByRelativeToCurrentProject(o.Value);
                        using (var fs = File.OpenRead(assemblyPath))
                        {
                            data = new byte[fs.Length];
                            fs.Read(data, 0, Convert.ToInt32(fs.Length));
                        }
                        if (data.Length == 0)
                        {
                            throw new ApplicationException("Failed to load " + assemblyPath);
                        }
                        return Assembly.Load(data);
                    })
                    .ToList(),

            };

            var csFilePath = path.Replace("T4FluentNH.tt.settings.xml", "T4FluentNH.cs"); //Get File name
            settings.WasModified = !File.Exists(csFilePath) ||
                                   File.GetLastWriteTime(path) > File.GetLastWriteTime(csFilePath);

            if(string.IsNullOrEmpty(settings.BaseEntityType))
                throw new Exception("BaseEntityType is not set");
            return settings;
        }

        public List<EntityType> EntityTypes { get; set; }

        public EntityType GetEntityType(VisualStudioHelper vsHelper, CodeClass2 codeClass, bool throwIfNotFound)
        {
            var eType = EntityTypes.FirstOrDefault(o => vsHelper.IsDerivedFrom(codeClass, o.DerivedFromType) || vsHelper.ContainBaseType(codeClass, o.DerivedFromType));
            if(eType == null && throwIfNotFound)
                throw new Exception("EntityType for type " + codeClass.FullName + " does not exists");
            return eType;
        }

        public EntityType GetExternalEntityType(string typeFullName, bool throwIfNotFound)
        {
            var type = ExternalAssemblies
                .Select(o => o.GetType(typeFullName))
                .Where(o => o != null)
                .FirstOrDefault();

            if(type == null)
                throw new Exception(typeFullName + " was not found in the external assembiles.");
            var dictEntityTypes = EntityTypes.ToDictionary(o => o.DerivedFromType);
            if (dictEntityTypes.ContainsKey(type.FullName))
                return dictEntityTypes[type.FullName];
            
            var currType = type;
            while (currType.BaseType != null)
            {
                if (dictEntityTypes.ContainsKey(currType.FullName))
                    return dictEntityTypes[currType.FullName];
                currType = currType.BaseType;
            }

            foreach (var i in type.GetInterfaces().Where(i => dictEntityTypes.ContainsKey(i.FullName)))
            {
                return dictEntityTypes[i.FullName];
            }

            if(throwIfNotFound)
                throw new Exception("EntityType that derives from type " + typeFullName + " does not exists");
            return null;
        }

        public bool IsExternalType(string typeFullName)
        {
            return ExternalAssemblies.Any(o => o.GetType(typeFullName) != null);
        }
        
        public string NotNullAttribute { get; set; }

        public string LengthAttribute { get; set; }
        
        public HashSet<string> IgnoreTypes { get; set; }

        public bool AsyncMethods { get; set; }

        public bool TypedMappingExtensions { get; set; }

        public bool ReadOnlyAttributeConvention { get; set; }

        public List<Singularize> Singularization { get; set; }

        public string BaseEntityType { get; set; }

        public CollectionMapType DefaultCollectionMapType { get; set; }

        public bool Strict { get; set; }

        public SyntheticProperties SyntheticProperties { get; set; }

        public GenerateMetadata GenerateMetadata { get; set; }

        public bool WasModified { get; set; }

        public List<Assembly> ExternalAssemblies { get;set; } 

    }


#>


<#+

public VisualStudioHelper VSHelper;

public class VisualStudioHelper : AutomationHelper
{
	private PluralizationService PluralizationService;
	private GeneratedTextTransformation Gtt;

	public VisualStudioHelper(GeneratedTextTransformation gtt) : base(gtt.Host)
	{
		Gtt = gtt;
		PluralizationService = PluralizationService.CreateService(CultureInfo.CreateSpecificCulture("en"));
	}

	public void Warning(string message)
    {
		Gtt.Warning(message);
    }

	public Dictionary<string, List<CodeClass2>> GetAllTypes(IEnumerable<ProjectItem> projectItems)
	{
		var result = new Dictionary<string, List<CodeClass2>>();
		foreach(ProjectItem item in projectItems)
		{
			ProcessTypes(item, (cls, pItem) => 
				{
					if(!result.ContainsKey(cls.FullName))
						result.Add(cls.FullName, new List<CodeClass2>());
					result[cls.FullName].Add(cls);
				});
		}
		return result;
	} 

	/// <summary>
    /// Provides access to the hosts solution startup project.
    /// </summary>
    public Project StartUpProject 
    {
        get
        {
            var startupProjectName = ((Array)DTE.Solution.SolutionBuild.StartupProjects).GetValue(0).ToString();
			
            var projects = GetAllProjects();
 
            foreach (var project in projects)
            {
                // returns object typeof(Project), not just project name
                if (project.UniqueName == startupProjectName)
                return project;
            }
            return null;
        }
    }

	/// <summary>
    /// Provides access to the application/web configuration file.
    /// </summary>
    /// <remarks>
    /// http://msdn.microsoft.com/en-us/library/system.configuration.configuration.aspx
    /// </remarks>
    public System.Configuration.Configuration Configuration(Project project)
    {
        string configurationFilename = null;
        foreach (ProjectItem item in project.ProjectItems)
        {
            if (!Regex.IsMatch(item.Name, "(app|web).config", RegexOptions.IgnoreCase)) 
                continue;
            configurationFilename = item.FileNames[0];
            break;
        }
 
        if(!string.IsNullOrEmpty(configurationFilename))
        {
            var configFile = new ExeConfigurationFileMap {ExeConfigFilename = configurationFilename};
            return System.Configuration.ConfigurationManager.OpenMappedExeConfiguration(configFile, ConfigurationUserLevel.None);
        }
    	return null;
    }

	public Project GetProjectContainingT4File()
	{
		// Fail if we couldn't get the DTE. This can happen when trying to run in TextTransform.exe
		if (DTE == null)
		{
			throw new Exception("T4 can only execute through the Visual Studio host");
		}
		// Find the .tt file's ProjectItem
		ProjectItem projectItem = DTE.Solution.FindProjectItem(Host.TemplateFile);

		// If the .tt file is not opened, open it
		if (projectItem.Document == null)
			projectItem.Open(Constants.vsViewKindCode);

		return projectItem.ContainingProject;
	}

	public string Pluralize(string name)
	{
		return PluralizationService.Pluralize(name);
	}

	public string Singularize(string name)
	{
		return PluralizationService.Singularize(name);
	}

	public List<CodeProperty> GetInheritedProperties(CodeClass2 codeClass)
    {
        return GetInheritedProperties((CodeType) codeClass);
    }

    public List<CodeProperty> GetInheritedProperties(CodeType element)
    {
        // If it's a local code element, we may be able to enumerate all its partial classes
        if (element.InfoLocation == vsCMInfoLocation.vsCMInfoLocationProject)
        {
            var codeClass2 = element as CodeClass2;
            if (codeClass2 != null)
            {
                var memberDict = new Dictionary<string, CodeElement>();
                foreach (var partialClass in codeClass2.PartialClasses.OfType<CodeType>())
                {
                    if (GetAttribute(partialClass.Attributes, "System.CodeDom.Compiler.GeneratedCodeAttribute") != null)
                        continue;
                    var baseMembers = partialClass.Bases.OfType<CodeType>().SelectMany(x => VisibleMembers(x).OfType<CodeElement>());
                    
                    // Ensure we only have one entry per name from all the bases
                    foreach (var baseMember in baseMembers) {
                        memberDict[baseMember.Name] = baseMember;
                    }
                }
                return memberDict.Values.OfType<CodeProperty>().ToList();
            }
        }
        return new List<CodeProperty>();
    }

    /// <summary>
    /// Finds a visible property matching any one of a set of possible names. The names are considered in
    /// priority order, with earlier entries in the array taking higher priority.
    /// </summary>
    public CodeProperty FindProperty(CodeType codeType, params string[] namesToMatch)
    {
        var candidateProperties = VisibleMembers(codeType).OfType<CodeProperty>().ToList();
        var comparison = vsProjectType.VisualBasicCodeModelLanguage.Equals(codeType.Language, StringComparison.OrdinalIgnoreCase)
                                ? StringComparison.OrdinalIgnoreCase // VB
                                : StringComparison.Ordinal;          // C#
        foreach (var name in namesToMatch) {
            var matchingProperty = candidateProperties.FirstOrDefault(x => string.Equals(x.Name, name, comparison));
            if (matchingProperty != null)
                return matchingProperty;
        }
        return null;
    }

    /// <summary>
    /// Scans all partial classes and all base types to get a list of all the
    /// members exposed by a type
    /// </summary>
    public CodeElements VisibleMembers(CodeType element)
    {
        if (element == null) throw new ArgumentNullException("element");

        // If it's a local code element, we may be able to enumerate all its partial classes
        if (element.InfoLocation == vsCMInfoLocation.vsCMInfoLocationProject)
        {
            var codeClass2 = element as CodeClass2;
            if (codeClass2 != null)
            {
                var partialsCodeElements = new List<CodeElement>();
                var isFirstPartialClass = true;
                foreach (var partialClass in codeClass2.PartialClasses.OfType<CodeType>()) {
                    partialsCodeElements.AddRange(VisibleMembersIgnorePartials(partialClass, includeBaseMembers: isFirstPartialClass).OfType<CodeElement>());
                    isFirstPartialClass = false; // Only scan base types once per partial class set, otherwise we'll get duplicates of the bases
                }
                return new ConcreteCodeElements(element, partialsCodeElements);
            }
        }

        return VisibleMembersIgnorePartials(element, true);
    }

    public CodeElements VisibleMembersIgnorePartials(CodeType element, bool includeBaseMembers)
    {
        var baseMembers = includeBaseMembers
                                ? element.Bases.OfType<CodeType>().SelectMany(x => VisibleMembers(x).OfType<CodeElement>())
                                : Enumerable.Empty<CodeElement>();

        var nameComparer = string.Equals(element.Language, vsProjectType.VisualBasicCodeModelLanguage, StringComparison.OrdinalIgnoreCase)
                                ? StringComparer.OrdinalIgnoreCase // VB has case-insensitive identifiers
                                : StringComparer.Ordinal;          // Supported other languages (C#) don't

        // Ensure we only have one entry per name from all the bases
        var memberDict = new Dictionary<string, CodeElement>(nameComparer);
        foreach (var baseMember in baseMembers) {
            memberDict[baseMember.Name] = baseMember;
        }

        // Now overlay members at this level
        foreach (var codeElement in element.Members.OfType<CodeElement>()) {
            if (IsPublic(codeElement))
                memberDict[codeElement.Name] = codeElement;
        }

        return new ConcreteCodeElements(element, memberDict.Values);
    }

    public bool IsPublic(CodeElement codeElement)
    {
        if (codeElement is CodeType)
            return ((CodeType)codeElement).Access == vsCMAccess.vsCMAccessPublic;
        if (codeElement is CodeProperty)
            return ((CodeProperty)codeElement).Access == vsCMAccess.vsCMAccessPublic;
        if (codeElement is CodeFunction)
            return ((CodeFunction)codeElement).Access == vsCMAccess.vsCMAccessPublic;
        if (codeElement is CodeVariable)
            return ((CodeVariable)codeElement).Access == vsCMAccess.vsCMAccessPublic;
        if (codeElement is CodeStruct)
            return ((CodeStruct)codeElement).Access == vsCMAccess.vsCMAccessPublic;
        if (codeElement is CodeDelegate)
            return ((CodeDelegate)codeElement).Access == vsCMAccess.vsCMAccessPublic;
        return false;
    }

	public string GetValidNHibernteEnumerableInterface(CodeProperty prop, string listImplType, bool strict, string newItemType = null) 
	{
		var typeName = GetPropertyType(prop);
        strict = false;
	    //if (typeName.Contains("IEnumerable"))
	     //   typeName = typeName.Replace("IEnumerable", listImplType);
	    if (!string.IsNullOrEmpty(newItemType))
	    {
	        typeName = Regex.Replace(typeName, "<([^.]+)>", "<" + newItemType + ">");
	    }
         

	    if (typeName.Contains("IEnumerable"))
	        return typeName;

	    if (typeName.Contains("HashSet") || typeName.Contains("ISet"))
	        return Regex.Replace(typeName, @"(?:HashSet|PersistentGenericSet)", strict ? "IEnumerable" : "ISet");
	    if (typeName.Contains("List") || typeName.Contains("IList"))
	        return Regex.Replace(typeName, @"(?:IList|List)", strict ? "IEnumerable" : "IList");
		if(typeName.Contains("Collection") || typeName.Contains("ICollection")) 
			return Regex.Replace(typeName, @"(?:ICollection|Collection)", strict ? "IEnumerable" : "ICollection");

		throw new Exception(string.Format("Type {0} is not enumerable", typeName));
	}

	public string GetEnumerableImplType(CodeProperty prop)
	{
	    var type = prop.Type;
		var typeName = type.CodeType.Name;
		if(new []{"List", "HashSet", "Collection"}.Contains(typeName)) return typeName;
		var baseTypes = GetBaseTypes(type).Select(o => o.Name).ToList();
		if(typeName == "ISet" || baseTypes.Contains("ISet") || GetAttribute(prop.Attributes, "FluentNHibernate.T4.Attributes.AsSetAttribute") != null) 
            return "HashSet";
		if(typeName == "IList" || baseTypes.Contains("IList")) return "List";
        if(typeName == "ICollection" || baseTypes.Contains("ICollection")) return "List";
	    if (typeName == "IEnumerable") return null;
		throw new Exception(string.Format("Type {0} is not enumerable", type.CodeType.Name));
	}

	public string GetClassName(string fullname)
	{
		return fullname.Split('.').Last();
	}

	public string GetClassNamespace(string fullname)
	{
		var arr = fullname.Split('.');
		return string.Join(".", arr.Take(arr.Length-1));
	}

	public string GetFieldName(string name)
	{
		return string.Format("_{0}", FirstCharToLower(name));
	}

	public string FirstCharToLower(string str)
	{
		return Char.ToLowerInvariant(str[0]) + str.Substring(1);
	}

	public bool IsSimpleOrNullableType(CodeTypeRef codeTypeRef)
    {
		var type = Type.GetType(codeTypeRef.AsFullName);
		if(type == null) return false; //External type
        return
            type.IsPrimitive ||
            type == typeof (Decimal) ||
            type == typeof (String) ||
            type == typeof (DateTime) ||
            type == typeof (TimeSpan) ||
            type == typeof (DateTimeOffset) ||
            IsNullable(type);
    }

    public bool IsValueType(string typeFullName)
    {
        var type = Type.GetType(typeFullName);
	    if(type == null) return false; //External type
        return type.IsValueType;
    }

    public string SimplifyTypeName(string typeFullName)
    {
        switch (typeFullName)
        {
            case "System.Int16":
                return "short";
            case "System.Int32":
                return "int";
            case "System.Int64":
                return "long";
            case "System.String":
                return "string";
            case "System.Decimal":
                return "decimal";
            default:
                return typeFullName;
        }
    }

    public bool IsSimpleType(string typeFullName)
    {
        var type = Type.GetType(typeFullName);
		if(type == null) return false; //External type
        return
            type.IsPrimitive ||
            type == typeof (Decimal) ||
            type == typeof (String) ||
            type == typeof (DateTime) ||
            type == typeof (TimeSpan) ||
            type == typeof (DateTimeOffset);
    }

    public bool IsSimpleType(CodeTypeRef codeTypeRef)
    {
        return IsSimpleType(codeTypeRef.AsFullName);
    }

    public bool IsNullable(CodeTypeRef codeTypeRef)
    {
		var type = Type.GetType(codeTypeRef.AsFullName);
        return Nullable.GetUnderlyingType(type) != null;
    }

	public string FirstCharToUpper(string input)
	{
		if (String.IsNullOrEmpty(input))
			throw new ArgumentException("ARGH!");
		return input.First().ToString().ToUpper() + String.Join("", input.Skip(1));
	}

	public bool IsEnumerable(CodeTypeRef type) //not working for dict
	{
		if(type.TypeKind == vsCMTypeRef.vsCMTypeRefOther)
		{
			throw new Exception(string.Format("Can not evaluate type {0}", type.AsFullName));
			//return false;
		}
		var baseTypes = GetBaseTypes(type).Select(o => o.Name).ToList();
		baseTypes.Add(type.CodeType.Name);
		return 
			baseTypes.Contains("IEnumerable") || 
			baseTypes.Contains("HashSet") ||
			baseTypes.Contains("Collection") ||
			baseTypes.Contains("List"); 
	}

    public string Trim(string str, string prefix, string postfix)
    {
        return TrimEnd(TrimStart(str, prefix), postfix);
    }

    public string TrimEnd(string str, string trim)
    {
        if (string.IsNullOrEmpty(str)) return str;
        return (str.EndsWith(trim))
            ? str.Substring(0, str.Length - trim.Length)
            : str;
    }

    public string TrimStart(string str, string trim)
    {
        if (string.IsNullOrEmpty(str)) return str;
        return (str.StartsWith(trim))
            ? str.Substring(trim.Length, str.Length - trim.Length)
            : str;
    }

	public List<CodeElement> GetBaseTypes(CodeTypeRef type)
	{
		var result = new List<CodeElement>();
		if(type.TypeKind == vsCMTypeRef.vsCMTypeRefOther)
		{
			//Warning(string.Format("Can not get base types for type {0}", type.AsFullName));
			return result;
		}
        
		for(var i=1; i <= (type.CodeType.Bases.Count); i++)
		{
			result.Add(type.CodeType.Bases.Item(i));
		}
		return result;
	}

	public List<string> GetBaseTypeNames(CodeClass2 cls)
	{
		var result = new List<string>();
		for(var i=1; i <= (cls.Bases.Count); i++)
		{
			result.Add(cls.Bases.Item(i).Name);
		}
		return result;
	}

	public List<string> GetBaseTypeFullNames(CodeClass2 cls)
	{
		var result = new List<string>();
		for(var i=1; i <= (cls.Bases.Count); i++)
		{
			result.Add(cls.Bases.Item(i).FullName);
		}
		return result;
	}

    public bool IsDerivedFrom(CodeClass2 cls, string fullName)
    {
		//In VS2015 the IsDerivedFrom method is not working as it should
        if (VisualStudioVersion < 14) return cls.IsDerivedFrom[fullName];

        if (cls == null) return false;
        if (cls.FullName == fullName) return true;

        for(var i=1; i <= cls.Bases.Count; i++)
        {
            var baseClass = (CodeClass2) cls.Bases.Item(i);
            if (baseClass == null)
            {
                Warning(cls.Bases.Item(i).FullName + " is not CodeClass2");
            }
            if (IsDerivedFrom(baseClass, fullName)) return true;
        }

        for (var i = 1; i <= cls.ImplementedInterfaces.Count; i++)
        {
            if (cls.ImplementedInterfaces.Item(i).FullName == fullName) return true;
        }

        return false;
    }


	public bool IsController(CodeClass2 type)
	{
		// Ignore any class which name doesn't end with "Controller"
		if (!type.FullName.EndsWith("Controller")) return false;

		for (; type.FullName != "System.Web.Mvc.Controller"; type = (CodeClass2)type.Bases.Item(1))
		{
			if (type.Bases.Count == 0)
				return false;
		}
		return true;
	}

	public bool IsGeneric(CodeTypeRef type)
	{
		return GetGenericAgruments(type).Any();
	}

	public List<string> GetGenericAgruments(CodeTypeRef type)
	{
		var result = new List<string>();
		if(type.TypeKind == vsCMTypeRef.vsCMTypeRefOther)
		{
			//Warning(string.Format("Can not get generic arguments for type {0}", type.AsFullName));
			return result;
		}
		return GetGenericAgruments(type.CodeType.FullName);
		
	}

	public List<string> GetGenericAgruments(string fullName)
	{
		var result = new List<string>();
		var genArgs = fullName.Split('<', '>');
		if(genArgs.Length <= 1) return result;
		foreach(var arg in genArgs[1].Split(','))
		{
			result.Add(arg);
		}
		return result;
    }

	public bool IsProtectedInternal(vsCMAccess access)
	{
		return access == vsCMAccess.vsCMAccessProjectOrProtected && 
			(access != vsCMAccess.vsCMAccessProtected && access != vsCMAccess.vsCMAccessProject);
	}

	public bool IsNHibernateProperty(CodeProperty prop)
    {
		return (IsProtectedInternal(prop.Access) || prop.Access == vsCMAccess.vsCMAccessPublic) && prop.Setter != null;
    }

	public void SetAsProtectedInternal(CodeProperty prop)
	{
		prop.Access = vsCMAccess.vsCMAccessProjectOrProtected;
	}

	public void SetAsPublic(CodeProperty prop)
	{
		prop.Access = vsCMAccess.vsCMAccessPublic;
	}

	public void SetAsPartial(CodeClass2 type)
	{
		if (type.ClassKind != vsCMClassKind.vsCMClassKindPartialClass)
		{
			try
			{
				type.ClassKind = vsCMClassKind.vsCMClassKindPartialClass;
			}
			catch
			{
				//Warning("SetAsPartial");
				return;
			}
			//Warning(String.Format("{0} changed the class {1} to be partial", T4FileName, type.Name));
		}
	}

	public void SetSetter(CodeProperty prop, string text)
	{
		SetCodeFunctionText(prop.Setter, text);
	}

	public void SetGetter(CodeProperty prop, string text)
	{
		SetCodeFunctionText(prop.Getter, text);
	}

	public void SetAsVirtual(CodeProperty2 prop)
	{
	    if (prop.OverrideKind == vsCMOverrideKind.vsCMOverrideKindVirtual || prop.Access == vsCMAccess.vsCMAccessPrivate) return;
	    var getterText = prop.Getter != null ? GetCodeFunctionText(prop.Getter) : null;
	    var setterText = prop.Setter != null ? GetCodeFunctionText(prop.Setter) : null;
	    prop.OverrideKind = vsCMOverrideKind.vsCMOverrideKindVirtual; //bug with auto-properties
	    if (getterText != null)
	    {
	        SetCodeFunctionText(prop.Getter, getterText);
	    }
	    if (setterText != null)
	    {
	        SetCodeFunctionText(prop.Setter, setterText);
	    }
	}

	public string GetPropertyType(CodeProperty prop)
	{
		if (prop.InfoLocation == vsCMInfoLocation.vsCMInfoLocationExternal)
	    {
	        return prop.Type.AsFullName;
	    }

		var codeStart = prop.StartPoint.CreateEditPoint();
		var codeFinish = prop.EndPoint;
		var functionText = codeStart.GetText(codeFinish);
		var match = Regex.Match(functionText, string.Format(@"([public\s|private\s|protected\s|internal\s|virtual\s|static\s]+)(.+?(?= {0}))", prop.Name));
		if (!match.Success || match.Groups.Count < 3) 
			throw new Exception("Failed to get property type for property " + prop.Name);
		return match.Groups[2].Value;
	}

	public void SetPropertyType(CodeProperty prop, string type)
	{
		var codeStart = prop.StartPoint.CreateEditPoint();
		var codeFinish = prop.EndPoint;
		var functionText = codeStart.GetText(codeFinish);
		var currentType = GetPropertyType(prop);
		codeStart.ReplaceText(codeFinish.CreateEditPoint(), functionText.Replace(currentType, type), (int)vsEPReplaceTextOptions.vsEPReplaceTextAutoformat);
	}

	public void SetPropertyBody(CodeProperty prop, string body)
	{
		//VS2015 makes an empty line before the first bracer
	    if (VisualStudioVersion >= 14)
	    {
	        var regex = new Regex(Regex.Escape(Environment.NewLine));
			body = regex.Replace(body, "", 1);
	    }
		
	    //body = body.Replace(Environment.NewLine, "");
		var codeStart = prop.StartPoint.CreateEditPoint();
		var codeFinish = prop.EndPoint;
		var functionText = codeStart.GetText(codeFinish);
		functionText = functionText.Substring(0, functionText.IndexOf('{')-1) + body;
		var currentType = GetPropertyType(prop);
		codeStart.ReplaceText(codeFinish.CreateEditPoint(), functionText, (int)vsEPReplaceTextOptions.vsEPReplaceTextAutoformat);
	}

	public string GetCodeFunctionText(CodeFunction codeFunction)
	{
		var codeStart = codeFunction.StartPoint;
		var codeFinish = codeFunction.EndPoint;
		return codeStart.CreateEditPoint().GetText(codeFinish);
	}

	public void SetCodeFunctionText(CodeFunction codeFunction, string text)
	{
		var codeStart = codeFunction.StartPoint;
		var codeFinish = codeFunction.EndPoint;
		var editPoint = codeStart.CreateEditPoint();
		editPoint.Delete(codeFinish);
		editPoint.Insert(text);
	}


	public bool ContainBaseType(CodeClass2 type, string baseType)
	{
		for (; type.FullName != baseType; type = (CodeClass2)type.Bases.Item(1))
		{
			if (type.Bases.Count == 0)
				return false;
		}
		return true;
	}

	// Check if the class has any explicit constructor
	public bool HasExplicitConstructor(CodeClass2 codeClass)
	{
		return codeClass.Members.OfType<CodeFunction2>().Any(
			f => !f.IsShared && f.FunctionKind == vsCMFunction.vsCMFunctionConstructor);
	}

	// Check if the class has a default (i.e. no params) constructor
	public bool HasExplicitDefaultConstructor(CodeClass2 codeClass)
	{
		return codeClass.Members.OfType<CodeFunction2>().Any(
			f => !f.IsShared && f.FunctionKind == vsCMFunction.vsCMFunctionConstructor && f.Parameters.Count == 0);
	}

    public IEnumerable<CodeProperty> GetProperties(IEnumerable<CodeClass2> codeClasses, bool includeInherited = false)
    {
        var props = new List<CodeProperty>();
        foreach (var codeClass in codeClasses)
        {
            props.AddRange(GetProperties(codeClass, includeInherited));
        }
        return props;
    }

    public IEnumerable<CodeProperty> GetProperties(CodeClass2 codeClass, bool includeInherited = false)
	{
		// Only look at regular method (e.g. ignore things like contructors)
		var props = codeClass.Members.OfType<CodeProperty>();
        if (includeInherited)
        {
            props = props.Union(GetInheritedProperties((CodeType) codeClass));
        }
        return props;
	}

	public IEnumerable<CodeFunction2> GetMethods(CodeClass2 codeClass, bool includeInherited = false)
	{
		// Only look at regular method (e.g. ignore things like contructors)
		var methods = codeClass.Members.OfType<CodeFunction2>()
			.Where(f => f.FunctionKind == vsCMFunction.vsCMFunctionFunction);
	    if (includeInherited)
	        methods = methods.Union(GetInheritedMethods((CodeType) codeClass));
	    return methods;
	}

	public IEnumerable<CodeFunction2> GetInheritedMethods(CodeType element)
    {
        // If it's a local code element, we may be able to enumerate all its partial classes
        if (element.InfoLocation == vsCMInfoLocation.vsCMInfoLocationProject)
        {
            var codeClass2 = element as CodeClass2;
            if (codeClass2 != null)
            {
                var memberDict = new Dictionary<string, CodeElement>();
                foreach (var partialClass in codeClass2.PartialClasses.OfType<CodeType>())
                {
                    if (GetAttribute(partialClass.Attributes, "System.CodeDom.Compiler.GeneratedCodeAttribute") != null)
                        continue;
                    var baseMembers = partialClass.Bases.OfType<CodeType>().SelectMany(x => VisibleMembers(x).OfType<CodeElement>());
                    
                    // Ensure we only have one entry per name from all the bases
                    foreach (var baseMember in baseMembers) {
                        memberDict[baseMember.Name] = baseMember;
                    }
                }
                return memberDict.Values.OfType<CodeFunction2>();
            }
        }
        return new List<CodeFunction2>();
    }

	public IEnumerable<CodeFunction2> GetActionResultMethods(CodeClass2 codeClass)
	{
		var methods = new List<CodeFunction2>();
		foreach (CodeFunction2 method in GetMethods(codeClass))
        {
            // Ignore non-public methods
            if (method.Access != vsCMAccess.vsCMAccessPublic)
                continue;

            // Ignore methods that are marked as not being actions
            if (GetAttribute(method.Attributes, "System.Web.Mvc.NonActionAttribute") != null)
                continue;

            // Ignore methods that are marked as Obsolete
            if (GetAttribute(method.Attributes, "System.ObsoleteAttribute") != null)
                continue;

            // Ignore generic methods
            if (method.IsGeneric)
                continue;

			// This takes care of avoiding generic types which cause method.Type.CodeType to blow up
            if (method.Type.TypeKind != vsCMTypeRef.vsCMTypeRefCodeType || !(method.Type.CodeType is CodeClass2))
                continue;

			// We only support action methods that return an ActionResult and Task<ActionResult> derived types
            if (!method.Type.CodeType.get_IsDerivedFrom("System.Web.Mvc.ActionResult") && method.Type.CodeType.FullName !="System.Threading.Tasks.Task<System.Web.Mvc.ActionResult>")
            {
                Warning(String.Format("doesn't support {1}.{2} because it doesn't return a supported {3} type", codeClass.Name, method.Name, method.Type.CodeType.FullName));
                continue;
            }
			methods.Add(method);
        }
		return methods;
	}

	public CodeFunction2 GetMethod(CodeClass2 codeClass, string name, bool allowInherited = false)
	{
		return GetMethods(codeClass, allowInherited).FirstOrDefault(f => f.Name == name);
	}

    public string GetAttributeArgumentValue(CodeAttribute2 attribute, string argumentName)
    {
        if (attribute == null) return null;
        var patternFormat = @"{0}[^=]*=[\s]*([^$]+)";
        var match = Regex.Match(attribute.Value, String.Format(patternFormat, argumentName), RegexOptions.IgnoreCase);
        if (!match.Success) return null;
        return match.Groups[1].Value.TrimEnd();
    }

    public CodeAttribute2 GetAttribute(CodeElements attributes, string attributeType)
	{
		for (int i = 1; i <= attributes.Count; i++)
		{
			try
			{
				var attrib = (CodeAttribute2)attributes.Item(i);
				if (attributeType.Split(',').Contains(attrib.FullName, StringComparer.OrdinalIgnoreCase))
				{
					return attrib;
				}
			}
			catch
			{
				// FullName can throw in some cases, so just ignore those attributes
				continue;
			}
		}
		return null;
	}

	public string MakeClassName(string ns, string classname)
	{
		return String.IsNullOrEmpty(ns) ? classname :
			String.IsNullOrEmpty(classname) ? ns : ns + "." + classname;
	}

	public string GetVirtualPath(ProjectItem item)
	{
		string fileFullPath = item.FileNames[0];
		var appRoot = Path.GetDirectoryName(item.ContainingProject.FullName) + "\\";

		if (!fileFullPath.StartsWith(appRoot, StringComparison.OrdinalIgnoreCase))
			throw new Exception(string.Format("File {0} is not under app root {1}. Please report issue.", fileFullPath, appRoot));

		// Make a virtual path from the physical path
		return "~/" + fileFullPath.Substring(appRoot.Length).Replace('\\', '/');
	}

	//Example SubProjectFolder\Item.cs
	public string GetRelativePathToCurrentProject(ProjectItem item)
	{
		string fileFullPath = item.FileNames[0];
		var appRoot = Path.GetDirectoryName(item.ContainingProject.FullName) + "\\";

		if (!fileFullPath.StartsWith(appRoot, StringComparison.OrdinalIgnoreCase))
			throw new Exception(string.Format("File {0} is not under app root {1}. Please report issue.", fileFullPath, appRoot));

		// Make a virtual path from the physical path
		return fileFullPath.Substring(appRoot.Length);
	}

	public string GetFullPathByRelativeToCurrentProject(string relative)
    {
        return Path.Combine(Path.GetDirectoryName(CurrentProject.FullName), relative);
    }

	public void ProcessTypes(ProjectItem file, Action<CodeClass2, ProjectItem> typeAction)
	{
		if(file.FileCodeModel != null)
		{
			// Process all the elements that are namespaces
			foreach (var ns in file.FileCodeModel.CodeElements.OfType<CodeNamespace>())
			{
				foreach (var type in ns.Members.OfType<CodeClass2>())
				{
					typeAction(type, file);
				}
			}
		}
	}

	public void ProcessFiles(IEnumerable<ProjectItem> folders, Action<ProjectItem, string> processAction)
	{
		foreach (ProjectItem item in folders)
		{
			if (IsFolder(item)) continue;
			processAction(item, item.Name);
		}
	}

	public void ProcessFiles(ProjectItem folder, Action<ProjectItem, string> processAction)
	{
		foreach (ProjectItem item in folder.ProjectItems)
		{
			if (IsFolder(item))
			{
				ProcessFiles(item, processAction);
			}
			else
				processAction(item, item.Name);
		}
	}

	public bool IsFolder(ProjectItem item)
	{
		return (item.Kind == Constants.vsProjectItemKindPhysicalFolder);
	}

	public bool IsNullable<T>(T obj)
	{
		if (obj == null) return true; // obvious
		return IsNullable(typeof(T));
	}

	public static bool IsNullable(Type type)
	{
		if (!type.IsValueType) return true; // ref-type
		if (Nullable.GetUnderlyingType(type) != null) return true; // Nullable<T>
		return false; // value-type
    }

}
#>


<#+
public class ClassTree
{
    public ClassTree(string fullName)
    {
        FullName = fullName;
        DepthLevel = !string.IsNullOrEmpty(FullName) ? FullName.Split('.').Count() : 0;
        SubClassTrees = new Dictionary<string, ClassTree>();
        AllSubClassTrees = new List<ClassTree>();
        Classes = new Dictionary<long, string>();
		Data = new Dictionary<long, Dictionary<string, string>>();
    }

    public string Name
    {
        get
        {
            return FullName == null ? null : FullName.Split('.').ToList().Last();
        }
    }

    public string Prefix
    {
        get
        {
            if (FullName == null) return null;
            var nsSlpit = FullName.Split('.').ToList();
            return String.Join(".", nsSlpit.Take(nsSlpit.Count - 1));
        }
    }

	public ClassTree Parent { get; private set; }

	public Dictionary<long, Dictionary<string, string>> Data { get; set; }

    public string FullName { get; set; }

    public int DepthLevel { get; private set; }

    public Dictionary<string, ClassTree> SubClassTrees { get; set; }

    public List<ClassTree> AllSubClassTrees { get; set; }

    public Dictionary<long, string> Classes { get; private set; }

    public string GetUniqueName()
    {
        return GetUniqueName(Name);
    }

    private string GetUniqueName(string name)
    {
        if (Parent == null) return Name;
        return Parent.GetUniqueName() + name;
    }

    public void AddClass(long id, string name, string nsName, Dictionary<string, string> data = null)
    {
        var ns = AddSubClass(nsName);               
        ns.Classes[id] = name;
		ns.Data[id] = data;
    }

    public ClassTree AddSubClass(string fullName)
    {
        ClassTree result = null;
        ClassTree child;
        if (String.IsNullOrEmpty(fullName)) return this;
        var nsSplit = fullName.Split('.').ToList();
        if (DepthLevel >= nsSplit.Count()) return null;
        var childName = nsSplit[DepthLevel];
        if (!SubClassTrees.ContainsKey(childName))
        {
            child = new ClassTree(String.Join(".", nsSplit.Take(DepthLevel + 1)));
            SubClassTrees.Add(childName, child);
            child.Parent = this;
            AllSubClassTrees.Add(child);
        }
        else
            child = SubClassTrees[childName];

        if ((DepthLevel + 1) < nsSplit.Count())
        {
            result = SubClassTrees[childName].AddSubClass(fullName);
            if (result != null)
                AllSubClassTrees.Add(result);
        }
        return (DepthLevel + 1) == nsSplit.Count() ? child : result;
    }
}
#>


<#+

public class DatabaseUnitOfWork : IDisposable
{
	private string _connectionString;
	private SqlConnection _sqlConnection;
	private SqlTransaction _transaction;

	public DatabaseUnitOfWork(string connectionString)
    {
		_connectionString = connectionString;
		_sqlConnection = new SqlConnection(connectionString);
		_sqlConnection.Open();
		_transaction = _sqlConnection.BeginTransaction();
    }

	public void OpenConnection()
    {
		_sqlConnection.Open();
		_transaction = _sqlConnection.BeginTransaction("UnitOfWork");
    }

	public void CloseConnection()
    {
		if(_sqlConnection.State != ConnectionState.Open) throw new Exception("conn not open!");
		_transaction.Commit();
		_sqlConnection.Close();
    }

	public SqlDataReader ExecuteReader(string queryString)
	{
		using(var command = new SqlCommand(queryString, _sqlConnection, _transaction))
        {
			var result = command.ExecuteReader();
			return result;
        }
	}

	public int ExecuteNonQuery(string queryString)
    {
		using(var command = new SqlCommand(queryString, _sqlConnection, _transaction))
        {
			return command.ExecuteNonQuery();
		}
	}

	public int ExecuteNonQuery(string queryString, params SqlParameter[] parameters)
    {
		using(var command = new SqlCommand(queryString, _sqlConnection, _transaction))
        {
			if(parameters != null)
				SetAsInputParameters(command, parameters);
			return command.ExecuteNonQuery();
		}
    }

	public TReturn ExecuteScalar<TReturn>(string queryString)
	{
		return ExecuteScalar<TReturn>(queryString, null);
	}

	public TReturn ExecuteScalar<TReturn>(string queryString, params SqlParameter[] parameters)
	{
		var returnType = typeof(TReturn);
		var convertTo = VisualStudioHelper.IsNullable(returnType)
			? Nullable.GetUnderlyingType(returnType)
			: returnType;
		using(var command = new SqlCommand(queryString, _sqlConnection, _transaction))
        {
			if(parameters != null)
				SetAsInputParameters(command, parameters);
			var result = command.ExecuteScalar();
			return result == null || result is DBNull
				? default(TReturn)
				: (TReturn) Convert.ChangeType(command.ExecuteScalar(), convertTo);
		}
    }

	private void SetAsInputParameters(SqlCommand command, SqlParameter[] parameters)
    {
		foreach(var parameter in parameters)
        {
			parameter.IsNullable = true;
			parameter.Direction = ParameterDirection.Input;
			if(parameter.Value == null)
				parameter.Value = DBNull.Value;
			command.Parameters.Add(parameter);
        }
    }

	public void Dispose()
    {
		CloseConnection();
		_sqlConnection.Dispose();
    }
}

#>


<#+
/*
    Manager.tt from Damien Guard: http://damieng.com/blog/2009/11/06/multiple-outputs-from-t4-made-easy-revisited
*/


// Manager class records the various blocks so it can split them up
class Manager {
    private class Block {
        public String Name;
        public int Start, Length;
    }

    private Block currentBlock;
    private List<Block> files = new List<Block>();
    private Block footer = new Block();
    private Block header = new Block();
    private ITextTemplatingEngineHost host;
    private StringBuilder template;
    protected List<String> generatedFileNames = new List<String>();

    public static Manager Create(ITextTemplatingEngineHost host, StringBuilder template) {
        return (host is IServiceProvider) ? new VSManager(host, template) : new Manager(host, template);
    }

    public void KeepGeneratedFile(String name) {
        name = Path.Combine(Path.GetDirectoryName(host.TemplateFile), name);
        generatedFileNames.Add(name);
    }
    
    public void StartNewFile(String name) {
        if (name == null)
            throw new ArgumentNullException("name");
        CurrentBlock = new Block { Name = name };
    }

    public void StartFooter() {
        CurrentBlock = footer;
    }

    public void StartHeader() {
        CurrentBlock = header;
    }

    public void EndBlock() {
        if (CurrentBlock == null)
            return;
        CurrentBlock.Length = template.Length - CurrentBlock.Start;
        if (CurrentBlock != header && CurrentBlock != footer)
            files.Add(CurrentBlock);
        currentBlock = null;
    }

    public virtual void Process(bool split) {
        if (split) {
            EndBlock();
            var headerText = template.ToString(header.Start, header.Length);
            var footerText = template.ToString(footer.Start, footer.Length);
            var outputPath = Path.GetDirectoryName(host.TemplateFile);
            files.Reverse();
            foreach (var block in files) {
                String fileName = Path.Combine(outputPath, block.Name);
				if(File.Exists(fileName))
					File.SetLastWriteTime(fileName, DateTime.Now);
                String content = headerText + template.ToString(block.Start, block.Length) + footerText;
                generatedFileNames.Add(fileName);
                CreateFile(fileName, content);
                template.Remove(block.Start, block.Length);
            }
        }
    }

    public string GetAllContent()
    {
        var headerText = template.ToString(header.Start, header.Length);
        var footerText = template.ToString(footer.Start, footer.Length);
        var bodyText = string.Join(Environment.NewLine, files.Select(b=> template.ToString(b.Start, b.Length)));
        return headerText + bodyText + footerText;
    }

    protected virtual void CreateFile(String fileName, String content) {
        if (IsFileContentDifferent(fileName, content))
            File.WriteAllText(fileName, content);
    }

    public virtual String GetCustomToolNamespace(String fileName) {
        return null;
    }

    public virtual String DefaultProjectNamespace {
        get { return null; }
    }

    protected bool IsFileContentDifferent(String fileName, String newContent) {
        return !(File.Exists(fileName) && File.ReadAllText(fileName) == newContent);
    }

    private Manager(ITextTemplatingEngineHost host, StringBuilder template) {
        this.host = host;
        this.template = template;
    }

    private Block CurrentBlock {
        get { return currentBlock; }
        set {
            if (CurrentBlock != null)
                EndBlock();
            if (value != null)
                value.Start = template.Length;
            currentBlock = value;
        }
    }

    private class VSManager : Manager {
        private EnvDTE.ProjectItem templateProjectItem;
        private EnvDTE.DTE dte;
        private Action<String> checkOutAction;
        private Action<IEnumerable<String>> projectSyncAction;

        public override String DefaultProjectNamespace {
            get {
                return templateProjectItem.ContainingProject.Properties.Item("DefaultNamespace").Value.ToString();
            }
        }

        public override String GetCustomToolNamespace(string fileName) {
            return dte.Solution.FindProjectItem(fileName).Properties.Item("CustomToolNamespace").Value.ToString();
        }

        public override void Process(bool split) {
            if (templateProjectItem.ProjectItems == null)
                return;
            base.Process(split);
            projectSyncAction.EndInvoke(projectSyncAction.BeginInvoke(generatedFileNames, null, null));
        }

        protected override void CreateFile(String fileName, String content) {
            if (IsFileContentDifferent(fileName, content)) {
                CheckoutFileIfRequired(fileName);
                File.WriteAllText(fileName, content);
            }
        }

        internal VSManager(ITextTemplatingEngineHost host, StringBuilder template)
            : base(host, template) {
            var hostServiceProvider = (IServiceProvider)host;
            if (hostServiceProvider == null)
                throw new ArgumentNullException("Could not obtain IServiceProvider");
            dte = (EnvDTE.DTE)hostServiceProvider.GetService(typeof(EnvDTE.DTE));
            if (dte == null)
                throw new ArgumentNullException("Could not obtain DTE from host");
            templateProjectItem = dte.Solution.FindProjectItem(host.TemplateFile);
            checkOutAction = (String fileName) => dte.SourceControl.CheckOutItem(fileName);
            projectSyncAction = (IEnumerable<String> keepFileNames) => ProjectSync(templateProjectItem, keepFileNames);
        }

        private static void ProjectSync(EnvDTE.ProjectItem templateProjectItem, IEnumerable<String> keepFileNames) {
            var keepFileNameSet = new HashSet<String>(keepFileNames);
            var projectFiles = new Dictionary<String, EnvDTE.ProjectItem>();
            var originalFilePrefix = Path.GetFileNameWithoutExtension(templateProjectItem.get_FileNames(0)) + ".";
            foreach (EnvDTE.ProjectItem projectItem in templateProjectItem.ProjectItems)
                projectFiles.Add(projectItem.get_FileNames(0), projectItem);

            // Remove unused items from the project
            foreach (var pair in projectFiles)
                if (!keepFileNames.Contains(pair.Key) && !(Path.GetFileNameWithoutExtension(pair.Key) + ".").StartsWith(originalFilePrefix))
                    pair.Value.Delete();

            // Add missing files to the project
            foreach (String fileName in keepFileNameSet)
                if (!projectFiles.ContainsKey(fileName))
                    templateProjectItem.ProjectItems.AddFromFile(fileName);
        }

        private void CheckoutFileIfRequired(String fileName) {
            var sc = dte.SourceControl;
            if (sc != null && sc.IsItemUnderSCC(fileName) && !sc.IsItemCheckedOut(fileName))
                checkOutAction.EndInvoke(checkOutAction.BeginInvoke(fileName, null, null));
        }
    }
}

/*
    End of Manager.tt
*/
#>


<#+
/// <summary>
/// Object that provides functionality for automating Visual Studio.
/// </summary>
//public AutomationHelper VisualStudioHelper;

/// <summary>
/// This class provides functionality for automating Visual Studio.
/// </summary>
public class AutomationHelper 
{
	/// <summary>
	/// Creates a new instance of this class
	/// </summary>
	public AutomationHelper(object host)
	{
		// store a reference to the template host
		// we will need this frequently
		this.Host = host as ITextTemplatingEngineHost;
	}
	
	private EnvDTE.DTE _DTE = null;
	/// <summary>
	/// Returns a reference to the primary management object of Visual Studio
	/// <summary>
	public EnvDTE.DTE DTE
	{
		get
		{
			if (_DTE == null)
            {
				var hostServiceProvider = this.Host as IServiceProvider;
				if (hostServiceProvider != null)
					_DTE = hostServiceProvider.GetService(typeof(EnvDTE.DTE)) as EnvDTE.DTE;
            }
			return _DTE;
		}
	}
	
	/// <summary>
	/// Stores a reference to the Host of the t4 template
	/// </summary>
	public ITextTemplatingEngineHost Host { get; private set; }


	#region Solution and Projects
	/// <summary>
	/// Gets the full path of the solution file
	/// </summary>
	public string SolutionFile
    {
		get
        {
			return this.DTE.Solution.FileName;
        }
    }
	/// <summary>
	/// Gets the file name of the currently opened solution.
	/// </summary>
	public string SolutionFileName
    {
		get
        {
			return System.IO.Path.GetFileName(this.DTE.Solution.FileName);
        }
    }
	/// <summary>
	/// Gets the name of the currently opened solution
	/// </summary>
	public string SolutionName
    {
		get
        {
			return this.DTE.Solution.Properties.Item("Name").Value.ToString();
        }
    }

	/// <summary>
	/// Gets a list of all Projects within the solution
	/// </summary>
	public IEnumerable<EnvDTE.Project> GetAllProjects()
    {
		var ret = new List<EnvDTE.Project>();

		// take all projects that are at top level of the solution
		// and recursively search Project folders
		var topLevelProjects = this.DTE.Solution.Projects;

		foreach(EnvDTE.Project project in topLevelProjects)
        {
			if (project.Kind == vsProjectType.SolutionFolder)
				ret.AddRange(GetProjectsFromItemsCollection(project.ProjectItems));
			else
				ret.Add(project);
        }

		return ret;
    }
	/// <summary>
	/// Gets the project object within the current solution by a given project name.
	/// </summary>
	public EnvDTE.Project GetProject(string projectName)
    {
		return this.GetAllProjects()
				   .Where(p => p.Name == projectName)
				   .First();
    }
	/// <summary>
	/// Gets the project containing the .tt-File
	/// </summary>
	public EnvDTE.Project CurrentProject
    {
		get
        {
			return this.FindProjectItem(this.Host.TemplateFile).ContainingProject;
        }
    }

    public decimal VisualStudioVersion
    {
        get { return decimal.Parse(CurrentProject.DTE.Version); }
    }

	#endregion

	#region Project Items
	public EnvDTE.ProjectItem FindProjectItem(string fileName)
    {
		return this.DTE.Solution.FindProjectItem(fileName);
    }
	/// <summary>
	/// Gets all project items from the current solution
	/// </summary>
	public IEnumerable<EnvDTE.ProjectItem>GetAllSolutionItems()
    {
		var ret = new List<EnvDTE.ProjectItem>();

		// iterate all projects and add their items
		foreach(EnvDTE.Project project in this.GetAllProjects())
			ret.AddRange(GetAllProjectItems(project));

		return ret;
    }
	/// <summary>
	/// Gets all project items from the current project
	/// </summary>
	public IEnumerable<EnvDTE.ProjectItem>GetAllProjectItems()
    {
		// get the project of the template file and reeturn all its items
		var project = this.CurrentProject;
		return GetAllProjectItems(project);
    }
	/// <summary>
	/// Gets all Project items from a given project. 
	/// </summary>
	public IEnumerable<EnvDTE.ProjectItem>GetAllProjectItems(EnvDTE.Project project)
    {
		return this.GetProjectItemsRecursively(project.ProjectItems);
    }
	#endregion

	#region Code Model
	/// <summary>
    /// Searches a given collection of CodeElements recursively for objects of the given elementType.
    /// </summary>
    /// <param name="elements">Collection of CodeElements to recursively search for matching objects in.</param>
    /// <param name="elementType">Objects of this CodeModelElement-Type will be returned.</param>
    /// <param name="includeExternalTypes">If set to true objects that are not part of this solution are retrieved, too. E.g. the INotifyPropertyChanged interface from the System.ComponentModel namespace.</param>
    /// <returns>A list of CodeElement objects matching the desired elementType.</returns>
    public List<EnvDTE.CodeElement> GetAllCodeElementsOfType(EnvDTE.CodeElements elements, EnvDTE.vsCMElement elementType, bool includeExternalTypes)
    {
        var ret = new List<EnvDTE.CodeElement>();

        foreach (EnvDTE.CodeElement elem in elements)
        {
            // iterate all namespaces (even if they are external)
            // > they might contain project code
            if (elem.Kind == EnvDTE.vsCMElement.vsCMElementNamespace)
            {
                ret.AddRange(GetAllCodeElementsOfType(((EnvDTE.CodeNamespace)elem).Members, elementType, includeExternalTypes));
            }
            // if its not a namespace but external
            // > ignore it
            else if (elem.InfoLocation == EnvDTE.vsCMInfoLocation.vsCMInfoLocationExternal
                    && !includeExternalTypes)
                continue;
            // if its from the project
            // > check its members
            else if (elem.IsCodeType)
            {
                ret.AddRange(GetAllCodeElementsOfType(((EnvDTE.CodeType)elem).Members, elementType, includeExternalTypes));
            }

            // if this item is of the desired type
            // > store it
            if (elem.Kind == elementType)
                ret.Add(elem);
        }

        return ret;
    }
	#endregion


	#region Auxiliary stuff
	private List<EnvDTE.Project> GetProjectsFromItemsCollection(EnvDTE.ProjectItems items)
    {
		var ret = new List<EnvDTE.Project>();

		foreach(EnvDTE.ProjectItem item in items)
        {
			if (item.SubProject == null)
				continue;
			else if (item.SubProject.Kind == vsProjectType.SolutionFolder)
				ret.AddRange(GetProjectsFromItemsCollection(item.SubProject.ProjectItems));
			else if (item.SubProject.Kind == vsProjectType.VisualBasic
				  || item.SubProject.Kind == vsProjectType.VisualCPlusPlus
				  || item.SubProject.Kind == vsProjectType.VisualCSharp
				  || item.SubProject.Kind == vsProjectType.VisualJSharp
				  || item.SubProject.Kind == vsProjectType.WebProject)
				ret.Add(item.SubProject);
        }

		return ret;
    }
	private List<EnvDTE.ProjectItem> GetProjectItemsRecursively(EnvDTE.ProjectItems items)
    {
		var ret = new List<EnvDTE.ProjectItem>();
        if (items == null) return ret;
		
		foreach(EnvDTE.ProjectItem item in items)
        {
			ret.Add(item);
			ret.AddRange(GetProjectItemsRecursively(item.ProjectItems));
        }

		return ret;
    }
	#endregion

	/// <summary>
	/// Gets the T4 template as vs projectitem.
	/// </summary>
	public EnvDTE.ProjectItem GetTemplateAsProjectItem()
	{
		return DTE.Solution.FindProjectItem(this.Host.TemplateFile);
	}
		
}

public class vsProjectType
{
	public const string SolutionFolder = "{66A26720-8FB5-11D2-AA7E-00C04F688DDE}";
	public const string VisualBasic = "{F184B08F-C81C-45F6-A57F-5ABD9991F28F}";
	public const string VisualCSharp = "{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}";
	public const string VisualCPlusPlus = "{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}";
	public const string VisualJSharp = "{E6FDF86B-F3D1-11D4-8576-0002A516ECE8}";
	public const string WebProject = "{E24C65DC-7377-472b-9ABA-BC803B73C61A}";
    public const string VisualBasicCodeModelLanguage = "{B5E9BD33-6D3E-4B5D-925E-8A43B79820B4}";
}


private class ConcreteCodeElements : MarshalByRefObject, CodeElements
{
    private readonly CodeType _primaryCodeType;
    private readonly IList<CodeElement> _codeElements;

    public ConcreteCodeElements(CodeType primaryCodeType, IEnumerable<CodeElement> codeElements)
    {
        _primaryCodeType = primaryCodeType;
        _codeElements = codeElements.ToList();
    }

    IEnumerator IEnumerable.GetEnumerator()
    {
        return _codeElements.GetEnumerator();
    }

    public CodeElement Item(object index)
    {
        if (index is int)
        {
            return _codeElements[(int)index];
        }
        throw new ArgumentException();
    }

    public void Reserved1(object element)
    {
        throw new NotImplementedException();
    }

    public bool CreateUniqueID(string prefix, ref string newName)
    {
        throw new NotImplementedException();
    }

    public DTE DTE
    {
        get { return _primaryCodeType.DTE; }
    }

    public object Parent
    {
        get { return _primaryCodeType; }
    }

    public int Count
    {
        get { return _codeElements.Count; }
    }

    IEnumerator CodeElements.GetEnumerator()
    {
        return _codeElements.GetEnumerator();
    }
}
#>
